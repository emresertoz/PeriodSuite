import "pathToSuite.mag": pathToSuite;

//************************************************************************************************
// Global constants.
//************************************************************************************************

declare verbose PicardFuchs, 2; SetVerbose("PicardFuchs", 2);
declare verbose AIOutput, 1;
SAFEOVERWRITECODE := ".PERIODSUITE-this-directory-is-safe-to-rm-fr";

//************************************************************************************************
// Directory management and File I/O
//************************************************************************************************


intrinsic PathToSuite() -> MonStgElt
{ Returns the directory of period-suite. }
  dir:=pathToSuite;
  if dir[#dir] ne "/" then dir:=dir*"/"; end if;
  return dir;
end intrinsic;


intrinsic PeriodSuiteStorageDir(:subfolder:="") -> MonStgElt
{
 Returns the directory for intermediate computational results that may be reused. 
}
  if #subfolder eq 0 then
    return PathToSuite()*"fermat_data/";
  else
    return PathToSuite()*"fermat_data/"*subfolder*"/";
  end if;
end intrinsic;

intrinsic IVPWorkingDir(:subfolder:="") -> MonStgElt
{
Returns either the directory for temp files of period-suite or, if subfolder is specified,
the directory to the identified subfolder.
}
  if #subfolder eq 0 then
    return PathToSuite()*"ode_storage/incinerator/";
  else 
    if subfolder[#subfolder] ne "/" then subfolder:=subfolder*"/"; end if;
    if subfolder[1] eq "/" then
    // Hacky way to force your way out of the root directory
      return subfolder;
    else
      return PathToSuite()*"ode_storage/"*subfolder;
    end if;
  end if;
end intrinsic;

intrinsic WriteInsideTempFolder(filename::MonStgElt, string::MonStgElt : Overwrite:=false, name:="",createFolder:=false)
{
  Writes the string to filename inside the appropriate folder within period-suite. Takes care of line breaking issues.
}
  cols := GetColumns();
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  target:=ivpdir*filename;
  SetColumns(0);
  if (#name gt 0) and createFolder then
    if System("[ -d "*ivpdir*" ]") gt 0 then
      System("mkdir "*ivpdir);
    end if;
  end if;
  Write(target,string : Overwrite:=Overwrite);
  SetColumns(cols);
end intrinsic;

intrinsic WriteInsideStorageFolder(filename::MonStgElt, string::MonStgElt : Overwrite:=false)
{
  Writes the string to filename inside the appropriate folder within period-suite. Takes care of line breaking issues.
}
  cols := GetColumns();
  target:=PeriodSuiteStorageDir()*filename;
  SetColumns(0);
  Write(target,string : Overwrite:=Overwrite);
  SetColumns(cols);
end intrinsic;

intrinsic WriteMetaFile(name, precision, path, reduce_initials : first_of_path_is_fermat:=false)
{ Writes the meta file in the initial value problem directory.}

  WriteInsideTempFolder("meta.sage","precision="*Sprint(precision) : name:=name);
  WriteInsideTempFolder("meta.sage","d="*Sprint(Degree(path[1]))   : name:=name);
  WriteInsideTempFolder("meta.sage","steps="*Sprint(#path-1)       : name:=name);
  
  if first_of_path_is_fermat then
      WriteInsideTempFolder("meta.sage","fermat_type="*Sprint(Coefficients(path[1])) : name:=name);
  end if;
  WriteInsideTempFolder("meta.sage","reduce="*Sprint(reduce_initials) : name:=name);

  // Finally, write the path as a string, to give a redundant internal directoy for safety.
  triplequote := "\"\"\"";
  WriteInsideTempFolder("meta.sage", "path_string = " * triplequote * Sprint(path) * triplequote
			: name:=name);
  
end intrinsic;

procedure CheckIfIVPDirectoryExists(name, ivpdir, overwrite)
    
  // if no name has been specified then set overwrite to true and clear ivpdir
  overwrite:=overwrite or (#name eq 0);

  // Unix conditional check to see if directory exists and if it is safe to overwrite.
  if System("[ -d "*ivpdir*" ]") eq 0 then

    error if System("[ -f "*ivpdir*SAFEOVERWRITECODE*" ]" ) ne 0,
	     "Safe overwrite file: '"*SAFEOVERWRITECODE*"' does not exist in directory. "*
	     "If you *really* want `rm -fr *` to run in this directory, create this file "*
	     "and try again.";

    error if not overwrite, "folder name already exists, change 'name' or set 'overwrite:=true'";
    System("rm -fr "*ivpdir * "*");
    System("touch "*ivpdir*SAFEOVERWRITECODE); // Reset the safe overwrite file.
  else 
    System("mkdir "*ivpdir);
    System("touch "*ivpdir*SAFEOVERWRITECODE);
  end if;

end procedure;

procedure CarefulInitializeIVPDirectory(name, ivpdir, overwrite)
    //{First ensures that the directory "ivpdir" exists. If overwrite is true, delete the IVP equation files in this directory. Otherwise, raise an error.}
	
  // if no name has been specified then set overwrite to true and clear ivpdir
  overwrite:=overwrite or (#name eq 0);
  deletable_file_globs := ["meta.sage", "IVP-*.sage", "BaseChange-*.sage", "bundle"];
    
  // Unix conditional check to see if directory exists and if it is safe to overwrite.
  if System("[ -d "*ivpdir*" ]") eq 0 then

    error if System("[ -f "*ivpdir*SAFEOVERWRITECODE*" ]") ne 0,
	     "Safe overwrite file: '"*SAFEOVERWRITECODE*"' does not exist in directory. "*
	     "If you *really* want `rm -fr *` to run in this directory, create this file "*
	     "and try again.";

    error if not overwrite, "folder name already exists, change 'name' or set 'overwrite:=true'";
    
    for glob in deletable_file_globs do
	glob_test_cmd := Sprintf("test -n \"$(find %o -maxdepth 1 -name '%o' -print -quit)\"",
				 ivpdir, glob);
	
	if System(glob_test_cmd) eq 0 then
	    System("rm -r " * ivpdir * glob);
	end if;
    end for;
    
  else 
    System("mkdir "*ivpdir);
    System("touch "*ivpdir*SAFEOVERWRITECODE);
  end if;

end procedure;


// Manage sage subprocess calls.
intrinsic CallIntegrator(script_name, ivpdir) -> RngIntElt
	  {Manage sage subprocess calls.}
	  
  print "\n\nStarting SageMath, this may take some time...\n\n";
  cmd_string := Sprintf("%o --ivpdir=%o", PathToSuite()*script_name, ivpdir);
  return System(Sprintf("$(which sage) %o", cmd_string));
end intrinsic;

//************************************************************************************************
// Fermat polynomial construction methods
//************************************************************************************************

intrinsic Fermat(n::RngIntElt,d::RngIntElt : type:=[1 : i in [1..n+2]], P:=PolynomialRing(Rationals(),n+2)) -> RngMPolElt
{ Returns the polynomial of a Fermat hypersurface of dimension n and of degree d}
  return &+[ type[i]*P.i^d : i in [1..Ngens(P)]];
end intrinsic;

intrinsic Fermat(P::RngMPol,d::RngIntElt : type:=[1 : i in [1..Ngens(P)]]) -> RngMPolElt
{ Returns the Fermat polynomial degree d in the polynomial ring P}
  return &+[ type[i]*P.i^d : i in [1..Ngens(P)]];
end intrinsic;



//************************************************************************************************
// Picard-Fuchs related functions.
//************************************************************************************************

// input: 
// L a nested list of polynomials
// f defines a smooth hypersurface
// depth is the nesting depth of L 
// output:
// GD reduction of polynomials of L wrt f
// in the same nesting structure of L
intrinsic GriffithsDwork(L::Any,f::RngMPolElt : depth:=0) -> SeqEnum
{
  Takes a nested list of polynomials L and returns the GD reduction of these polynomials on f in the same nesting structure of L. Depth is the number of layers of the nested list L, where depth=0 means L is a polynomial.
}


  P:=Parent(f);
  Q:=CoefficientRing(P);
  R:=PolynomialRing(Q,Ngens(P),"grevlex");
  f:=R!f;

  numVars:=Ngens(R);
  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  // compute the pole order l of a homogeneous form p*Omega/f^l
  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  // to be used only for homogeneous forms
  function GDhom(p)
    // avoid division by zero
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
    pTop := HomogeneousComponent(p,Degree(p));
    a,b:=GDhom(pTop);
    p := p-pTop+b;
    q := q+a;
    until p eq (R!0);
    return q;
  end function;

  // to GD reduce a nested list of forms L
  function GDdeep(L,localDepth)
    if localDepth gt 0 then
      return [GDdeep(p,localDepth-1) : p in L];
    else
      return P!GD(R!L);
    end if;
  end function;

  return GDdeep(L,depth); 

end intrinsic;

intrinsic PicardFuchs(forms::SeqEnum,f0::RngMPolElt,f1::RngMPolElt : max_order:=0, family_number:=0) -> SeqEnum
{Computes the Picard Fuchs equation for each form in forms over the family (1-t)*f0+t*f1.}

  P:=Parent(f0);
  Q:=CoefficientRing(P);
  numVars:=Ngens(P);

  K<t>:=FunctionField(Q);
  R<[x]>:=PolynomialRing(K,numVars);
  f:=(1-t)*(R!f0) + t*(R!f1);

  return PicardFuchs([R!form : form in forms],f : max_order:=max_order,family_number:=family_number);
end intrinsic;

intrinsic PicardFuchs(forms::SeqEnum,f::RngMPolElt : max_order:=0, family_number:=0) ->SeqEnum
{Here f is assumed to be a polynomial with coefficients in a function field. Computes the Picard Fuchs equation for each form in the family corresponding to f.}

  R:=Parent(f);
  K:=CoefficientRing(R);
  numVars:=Ngens(R);

  forms:=[R!form : form in forms];

  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  // Cache the Groebner basis
  t0 := Cputime();
  Groebner(J);
  t1 := Cputime();
  vprint AIOutput : "AIStream: GroebnerInit: ", t1-t0;
  
  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  //***********************
  // SMALL SUBFUNCTIONS
  
  // to be used only for homogeneous forms
  function GDhom(p)
    // check if ell(p) = 1
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
      pTop := HomogeneousComponent(p,Degree(p));
      a,b:=GDhom(pTop);
      p := p-pTop+b;
      q := q+a;
    until p eq (R!0);
    return q;
  end function;
  
  // differentiate the coefficients
  function delT(p)
    c,m:=CoefficientsAndMonomials(p);
    dc:=[Derivative(o):o in c];
    return Polynomial(dc,m);
  end function;
  dtf := delT(f);
  
  // differentiate hom forms
  delTHomForm := func<a | delT(a) - ell(a)*dtf * a>;
  
  // differentiate the form p*Omega/f^l
  function delTForm(p)
    comps:=HomogeneousComponents(p);
    return &+[delTHomForm(c) : c in comps];
  end function;

  // Check independence of the form `f` in the matrix ot forms `M`.
  // Return a boolean and an updated matrix-of-forms `M`
  function cumulativeIsIndependent(M, mons, f)

    f_mons:= Monomials(f);
    new_mons := Seqset(f_mons) diff Seqset(mons);

    // Expand the matrix to keep track of new monomials, if there are any.
    if not IsEmpty(new_mons) then
      mons := mons cat Setseq(new_mons);	 
      M := HorizontalJoin(M, ZeroMatrix(K, Nrows(M), #new_mons));
    end if;

    // Insert the coordinates of f into the new matrix.
    M := VerticalJoin(M, Matrix(K, [[MonomialCoefficient(f, m) : m in mons]] ));
      
    // Reduce the matrix M to Echelon form. The matrix has many 0 entries above pivots
    // by construction, so very few eliminations are performed.
    M := EchelonForm(M);
    v := Rows(M);

    return IsZero(v[#v]), M, mons;
  end function;
  
  //********************************
  // PICARD FUCHS SUBFUNCTION
  
  // The following ring is used only to store
  // the differential operators
  RR<D>:=PolynomialRing(K); 

  function PF(form : PFnumber:=0, TotalPFs:=0, max_order:=0)
      
    // Initialize.							    
    reducedDerivatives:=[form];
    message:=(family_number gt 0) select " -- Family number "*Sprint(family_number) else "";

    // Main loop
    vprint PicardFuchs : "\nComputing Picard-Fuchs equation number", PFnumber, "out of", TotalPFs,message,"\n";
    tstart:=Cputime();
    t2:="null";
    stopLoop:=false;
    current_order:=0;

    // Setup cached matrix of independent forms.
    reduced_forms_matrix := Matrix(K,0,0,[]); mons := [];
    stopLoop, reduced_forms_matrix, mons :=
	cumulativeIsIndependent(reduced_forms_matrix, mons, form);
    
    repeat

      // Compute Griffith-Dwork reduction of form.
      t0:=Cputime();
      
      current_order +:= 1;
      error if current_order eq max_order, "max order exceeded";

      lastDerivative := delTForm(reducedDerivatives[#reducedDerivatives]);
      lastDerivativeReduced := GD(lastDerivative);
      Append(~reducedDerivatives,lastDerivativeReduced);
      assert #reducedDerivatives gt 1;
      
      t1:=Cputime();
      vprintf PicardFuchs, 2 : "GD reduction took %o seconds. ", t1-t0;

      // ****
      // Construct the matrix to check independence.
      
      stopLoop, reduced_forms_matrix, mons :=
	  cumulativeIsIndependent(reduced_forms_matrix, mons, lastDerivativeReduced);
      
      // Check if all forms have degree 0.
      // if &+[Degree(a) : a in reducedDerivatives] eq 0 then t2 := Cputime(); break; end if;      
      
      t2:=Cputime();      
      vprintf PicardFuchs, 2 : "Checking independence took %o seconds.\n", t2-t1;

      // Timestamp printing for machine reading.
      vprintf AIOutput : "AIStream: %o\n", t2-t0;
    until stopLoop;

    t0:=Cputime();
    vprint PicardFuchs : "Found linearly dependent derivatives in", t0-tstart, "seconds.";
    vprint PicardFuchs : "Will now compute the linear relation.";
    
    mon:=&join[Seqset(Monomials(a)):a in reducedDerivatives];
    mon:=Setseq(mon);
    MM:=[[MonomialCoefficient(a,m):m in mon]:a in reducedDerivatives];    
    M:=Matrix(MM[1..(#MM-1)]);
    t1:=Cputime();
    vprintf PicardFuchs, 2 : "Computed the basismatrix in %o seconds. ", t1-t0;

    U:=VectorSpaceWithBasis(M);
    t2:=Cputime();
    vprintf PicardFuchs, 2 : "Constructed the vectorspace w/ basis in %o seconds. ", t2-t1;
    u:=U!MM[#MM];
    t3:=Cputime();
    vprintf PicardFuchs, 2 : "Computed the coordinates in %o seconds. ", t3-t2;
    coefs:=Append(Coordinates(U,-u),1);
    t4:=Cputime();
    vprint PicardFuchs : "Computing the linear relations took", t4-t0, "seconds.";
    vprint PicardFuchs : "The Picard-Fuchs equation number", PFnumber, "took", t4-tstart, "seconds to compute.";

    // Machine readable summary stamp.
    vprintf AIOutput : "AIStream: total-PF: %o, %o: %o\n", PFnumber, family_number, t4-tstart;
    
    return &+[coefs[i]*D^(i-1):i in [1..#coefs]], reducedDerivatives;
  end function;

  //*******************************
  
  PFeqns:=[RR|];
  derivativesOfForms:=[];

  for i in [1..#forms] do
    pf, dervs := PF(R!(forms[i]): PFnumber:=i, TotalPFs:=#forms, max_order:=max_order);
    Append(~derivativesOfForms,dervs);
    Append(~PFeqns,pf);
  end for;

  return PFeqns;

end intrinsic;

//************************************************************************************************
// Cohomology basis functions.
//************************************************************************************************


// pole_order_bound if non-zero constructs a cohomology basis which, using Griffiths residues, has pole order at most "pole_order_bound"
intrinsic CompatibleCohomologyBasis(f0::RngMPolElt,f1::RngMPolElt : pole_order_bound:=0) -> SeqEnum
{
Find a basis for cohomology compatible for both f0 and f1. If f1 is singular, returns a basis for f0.
}
  if not isSmooth(f1) then return ComputeCohomologyBasis(f0); end if;

  d:=Degree(f0);
  P:=Parent(f0);
  Q:=CoefficientRing(P);
  f1:=P!f1;

  // if pole_order_bound is 1 then the obvious basis is compatible
  if pole_order_bound eq 1 then
    return [mon : mon in MonomialsOfDegree(P,d-Ngens(P))];
  end if;
  
  // setting up the quotient maps to jacobi rings
  psis:=[**];
  for f in [f0,f1] do
    J:=Ideal([Derivative(f,i) : i in [1..Ngens(P)]]);
    //assert 1 in Saturation(J); // f is smooth
    A:=quo<P|J>;
    V,psi:=VectorSpace(A);
    Append(~psis,psi);
  end for;

  // first setup the holomorphic forms
  if d lt Ngens(P) then
    basis := [];
  else
    basis:=[mon : mon in MonomialsOfDegree(P,d-Ngens(P))];
  end if;
  
  // admissable pole orders
  if pole_order_bound eq 0 then pole_order_bound:=Ngens(P)-1; end if; 

  poles:=[l : l in [2..pole_order_bound] | l*d-Ngens(P) ge 0];
  // now find a basis of forms with higer pole order
  for l in poles do
    m:=l*d-Ngens(P);
    mons:=Setseq(MonomialsOfDegree(P,m));
    U:=VectorSpace(Rationals(),#mons);
    W:=[];
    // compute the two kernels from U to the Jacobi ring
    for psi in psis do
      mu:=hom<U->Codomain(psi)|[psi(m) : m in mons]>;
      Append(~W,Kernel(mu));
    end for;
    // find a simple basis of U which generates both quotient spaces
    // U/W[1] and U/W[2]
    basis := basis cat [P|&+[b[i]*mons[i]:i in [1..#mons]] : b in FindGoodBasis(U,W[1],W[2])];
  end for;

  return basis;
end intrinsic;


// input: K0, K1 two equi-dimensional subspaces of V
intrinsic FindGoodBasis(V::ModTupFld,K0::ModTupFld,K1::ModTupFld) -> SeqEnum
{
A set of 'simple' vectors in V generating both V/K0 and V/K1.  Simple means: either a basis of V or a sum of two basis elements of V.
}
  if not (Dimension(K1) eq Dimension(K0)) then
    error "FindGoodBasis can not be used with this input: quotients of different dimension"; 
  end if;

  if (Dimension(V) eq Dimension(K0)) then
    return [];
  end if;

  B:=Basis(V);
  goodBasis:=[];

  repeat 
    b0:=0; b1:=0; preference:=0;
    found:=false; i:=1;

    // try to find b that is neither in K0 or K1
    for b in B do
      if (b notin K0) and (b notin K1) then 
      found:=true;
      preference:=b;
      break;
      end if;
    end for;

    // otherwise find b that is not in K0 or K1 and mark it as such
    if not found then
      for b in B do
        if (b0 eq 0) and (b notin K0) then
          b0 := b; 
        end if;
        if (b1 eq 0) and (b notin K1) then
          b1 := b; 
        end if;
        if not (b0 eq 0 or b1 eq 0) then
          preference:=b0+b1;
          break;
        end if;
      end for;
    end if;

    K0:=K0 + sub<V|preference>;
    K1:=K1 + sub<V|preference>;
    Append(~goodBasis,preference);

  until Dimension(K0) eq Dimension(V);

  if not Dimension(K0) eq Dimension(K1) then
    error "a bug in goodBasis";
  end if;

  return goodBasis;

end intrinsic;


intrinsic ComputeCohomologyBasis(f::RngMPolElt : order:="grevlex") -> SeqEnum
{
  Computes a cohomology basis for f.
}

  if IsFermat(f) and (order eq "grevlex") then return FermatCohomologyBasis(f); end if;

  P:=Parent(f);
  Q:=CoefficientRing(P);
  R:=PolynomialRing(Q,Ngens(P),order);
  J:=JacobianIdeal(R!f);
  mJ:=LeadingMonomialIdeal(J);
  Q:=R/mJ;
  V,psi:=VectorSpace(Q);
  phi:=Inverse(psi);
  return [ P ! (R!m) : m in phi(Basis(V)) | (Degree(m)+Ngens(R)) mod Degree(f) eq 0];
end intrinsic;

intrinsic IsFermat(f::RngMPolElt) -> BoolElt
{ Checks if the polynomial f is of Fermat type. }

  P:=Parent(f); d:=Degree(f);
  g:=&+[MonomialCoefficient(f,P.i^d)*P.i^d : i in [1..Ngens(P)]];
  return (f-g) eq 0;

end intrinsic;

intrinsic FermatCohomologyBasis(n::RngIntElt,d::RngIntElt) -> SeqEnum
{
Computes a grevlex cohomology basis for the Fermat hypersurface of dimension n and degree d.  This is faster than the standard algorithm employed by ComputeCohomologyBasis.
}
  return FermatCohomologyBasis(Fermat(n,d));
end intrinsic;

intrinsic FermatCohomologyBasis(f::RngMPolElt) -> SeqEnum
{
  Computes a grevlex cohomology basis for the Fermat hypersurface cut out by f. This is faster than the standard algorithm employed by ComputeCohomologyBasis.
}

  assert IsFermat(f);

  function exponent_grevlex(exp1,exp2)
    assert #exp1 eq #exp2;
    if exp1 eq exp2 then return 0; end if;
    d1:=&+exp1; d2:=&+exp2;
    if d1 lt d2 then return -1; end if;
    if d1 gt d2 then return 1; end if;
    if d1 eq d2 then
      exp1rev:=Reverse(exp1); exp2rev:=Reverse(exp2); len:=#exp1;
      for i in [1..len] do
        if exp1rev[i] lt exp2rev[i] then return 1; end if;
        if exp1rev[i] gt exp2rev[i] then return -1; end if;
      end for;
      // equal exponents are caught earlier on.
    end if;
  end function;

  P:=Parent(f); d:=Degree(f); n:=Ngens(P)-2;
  last_exponent:=func<partial_exponent, l | l*d-&+partial_exponent-Ngens(P)>;
  function IsAdmissable(partial_exponent,l)
    lexp:=last_exponent(partial_exponent,l);
    if lexp lt 0 then return false; end if;
    if lexp gt d-2 then return false; end if;
    return true;
  end function;

  partials:=[ [term:term in tuple] : tuple in CartesianPower([0..(d-2)],n+1)];

  exps:=&cat[[ Append(partial,last_exponent(partial,l)) : partial in partials | IsAdmissable(partial,l) ] : l in [1..(n+1)]];

  // exps:=&cat[ [ [a,b,c,l*d-a-b-c-Ngens(P)] : a,b,c in [0..(d-2)] | (a+b+c le l*d) and (l*d-a-b-c-Ngens(P) le d-2) and (l*d-a-b-c-Ngens(P) ge 0) ] : l in [1..(n+1)]];
  Sort(~exps,exponent_grevlex);

  return [Monomial(P,e) : e in exps];
end intrinsic;


// input: 
// B1: a set of polynomials, which provide a basis of cohomology for f
// B2: a set of polynomials, to be viewed as elements of cohomology of f
// output: a matrix whose rows are the coordinates of B2 in the basis B1
intrinsic CoordinatesInCohomology(f::RngMPolElt,B1::[RngMPolElt],B2::[RngMPolElt]) -> AlgMatElt
{
  Given (B1) a set of polynomials which provide a basis of cohomology for f and another set of polynomials (B2), return a matrix whose rows are the coordinates of elements in B2 in terms of B1.
}
  rB:=GriffithsDwork([*B1,B2*],f : depth:=2); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(rB)]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1]];
  rb2:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return Matrix([Coordinates(W,W!b) : b in rb2]);
end intrinsic;


//input:
// B - a basis for cohomology
// L - a nested list of forms
// output:
// a nested list of row vectors, expressing the forms
// in terms of the basis
intrinsic CoordinatesInCohomology(f::RngMPolElt,B::[RngMPolElt],L::SeqEnum) -> SeqEnum
{
  Takes a basis B for cohomology of f and reduces the the nested list L and returns their coordinates in terms of B.
}
  rB:=GriffithsDwork([*[B],L*],f : depth:=3); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(&cat(rB))]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1,1]];
  rb2:=[[[MonomialCoefficient(b,m) : m in mons] : b in bb] : bb in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [[Coordinates(W,W!b) : b in bb] : bb in rb2];
end intrinsic;



// will only work if the solutions near 0 are all holomorphic
intrinsic LocalBasis(ode::RngUPolElt) -> SeqEnum
{
  Given an ODE with holomorphic solution space at t=0, this will compute the exponents of the reduced power series basis at 0.
}
  K:=CoefficientRing(Parent(ode));  
  cK:=CoefficientRing(K);
  // universal univariate ring
  cofs:=Coefficients(ode);
  mons:=Monomials(ode);

  F := RationalDifferentialField(cK);
  AssignNames(~F,["z"]);
  newCofs:=[F!c : c in cofs];

  R := DifferentialOperatorRing(F);
  AssignNames(~R,["D"]);
  newMons:=[(R.1)^Degree(m) : m in mons];

  U<T>:=PolynomialRing(cK);
  newode:=&+[ newCofs[i]*newMons[i] : i in [1..#mons]];
  indPol:=IndicialPolynomial(newode, Zeros(F.1)[1]);
  facts:=[ fact[1] : fact in Factorisation(indPol)];

  if &or[ Degree(fact) gt 1 : fact in facts] then 
    error "Indicial polynomial does not factor into linear terms";
  end if;

  // the roots of the inidical polynomial
  exps:=[-Coefficient(fact,0) : fact in facts];
  // they should be positive integers
  check:=&and[IsCoercible(Integers(),e) and (e ge 0) : e in exps];
  if check then
    exps:=[Integers()| e : e in exps];
  else
    print ode;
    print exps;
    error "Indicial polynomial does not have positive integral roots";
  end if;

  return Reverse(exps); 
end intrinsic;


//************************************************************************************************
// Functions to compute derivatives of forms.
//************************************************************************************************

intrinsic DifferentiateForm(numerator::RngMPolElt,f0::RngMPolElt,f1::RngMPolElt) -> RngMPolElt
{
 Differentiates the form numerator*Omega/((1-t)*f0 + t*f1)^l, and outputs the new numerator.
}
  d:=Degree(f0); nvars:=Ngens(Parent(f0));
  return &+[ -(Degree(homnum)+nvars)/d*(f1-f0)*homnum : homnum in HomogeneousComponents(numerator)];
end intrinsic;

// works with a form of the type numerator*Omega/((1-t)*f0 + t*f1)^l
intrinsic ComputeDerivatives(numerator::RngMPolElt, f0::RngMPolElt, f1::RngMPolElt, desiredDerivatives::[RngIntElt] : withFactorial:=true) -> EltSeq
{
  Differentiates the form numerator*Omega/((1-t)*f0 + t*f1)^l as many times as is specified by the list of integers desiredDerivatives and outputs the sequence of new numerators.
}
  dervs:=[numerator];
  for i in [1..Maximum(desiredDerivatives)] do
    Append(~dervs,DifferentiateForm(dervs[i],f0,f1));
  end for;
  if withFactorial then
    return [ 1/Factorial(i) * dervs[i+1] : i in desiredDerivatives];
  else
    return [ dervs[i+1] : i in desiredDerivatives];
  end if;
end intrinsic;


// input: list of ODEs
// output: list of order, degree pairs for each ODE
intrinsic Analytics(ODEs::[RngUPolElt]) -> SeqEnum
{
  Takes a list of ODEs and returns the list of [order,degree] pairs.
}
  pairs:=[];
  for ode in ODEs do
    code:=Coefficients(ode);
    codeN:=[Numerator(c) : c in code];
    codeD:=LCM([Denominator(c) : c in code]);
    cofs:=codeN cat [codeD];
    degs:=[Degree(c) : c in cofs];
    Append(~pairs,[Degree(ode),Max(degs)]);
  end for;
  return pairs;
end intrinsic;

intrinsic Analytics(ODEs::SeqEnum) -> SeqEnum
{
  Takes a nested list of ODEs and returns the nested list of [order,degree] pairs.
}
  return [Analytics(odes) : odes in ODEs];
end intrinsic;


 
//************************************************************************************************
//
// Functions for solving Initial Value Problems (IVPs).
//
//************************************************************************************************


// initial value problems
IVPs := recformat<ODEs,movingBasis,inits,changeBasis,t,analytics,integrationPath,pointsToAvoid,loop_position>;

// construct the initial value problems associated to a straight line homotopy between two hypersurfaces Z(f0) and Z(f1)
// alarm and max_order if not 0 may kill the Magma session, they must be used within disposable Magma sessions
// if pole_order_bound is non-zero, we will only use the cohomology entries whose pole order (as Griffiths residues) is bounded by pole_order_bound
intrinsic ConstructIVPs(f0::RngMPolElt, f1::RngMPolElt : alarm:=0, max_order:=0, pole_order_bound:=0, family_number:=0, pathfinder:=0, integrationPath:=[], reduce_initials:=true, precision:=200, f1_is_smooth:=isSmooth(f1)) -> Rec
{
  Computes the Picard Fuchs equations for each of a convenient base of forms over the family (1-t)*f0+t*f1. The initial conditions are expressed in the grevlex cohomology basis of f0. Also returns the time it took to compute the ODEs and their order, degree pairs.
}
  // self destruct after a set amount of time
  // Warning: this kills the Magma session if activated!
  if alarm gt 0 then Alarm(alarm); end if;

  B:=CompatibleCohomologyBasis(f0,f1 : pole_order_bound:=pole_order_bound);
  t0:=Cputime();
  ODEs:=PicardFuchs(B,f0,f1 : max_order:=max_order, family_number:=family_number);
  t1:=Cputime();

  // On successful termination end the alarm
  if alarm gt 0 then Alarm(0); end if;

  
  L:=[];
  for i in [1..#ODEs] do
    requiredDerivatives := LocalBasis(ODEs[i]);
    Append(~L,ComputeDerivatives(B[i],f0,f1,requiredDerivatives : withFactorial:=true));
  end for;
  

  if (not reduce_initials) and IsFermat(f0) then
    initialConditions:=massIntegrate(L,Degree(f0),Coefficients(f0) : precision:=precision); 
  else
    // automatically uses a faster algorithm for Fermat type hypersurfaces
    A0:=ComputeCohomologyBasis(f0 : order:="grevlex"); 
    initialConditions:=CoordinatesInCohomology(f0,A0,L);
  end if;

  if (pole_order_bound eq 0) and f1_is_smooth then
    // now compute grevlex basis A on f1 and compute the change of basis matrix from B to A
    A1:=ComputeCohomologyBasis(f1 : order:="grevlex"); 
    // the following matrix computes the matrix whose rows store the coordinates of entries in A1 in terms of the basis B 
    M:=CoordinatesInCohomology(f1,B,A1);
  else 
    A1:=B;
    // we don't have to change coordinates to a standard basis because this clause can be activated only if we are at the final hypersurface
    M:=IdentityMatrix(Integers(),#B);
  end if;

  // setting up integration paths, unless specified
  avoid:=[];
  loop_position:=-1;
  if #integrationPath eq 0 then
    // we will use the pathfinder algorithm specified by the integer pathfinder
    integrationPath,avoid,loop_position:=SetupIntegrationPath(f0,f1,pathfinder : f1_is_smooth:=f1_is_smooth);
  end if;

  ivps:=rec<IVPs | ODEs:=ODEs, movingBasis:=B, inits:=initialConditions, changeBasis:=M, t:=t1-t0, analytics:=Analytics(ODEs),loop_position:=loop_position>;
  ivps`integrationPath:=integrationPath;
  ivps`pointsToAvoid:=avoid;

  return ivps;

end intrinsic;


intrinsic ConstructAndWriteIVPs(f0::RngMPolElt, f1::RngMPolElt : pole_order_bound:=0, family_number:=0, max_number:=0, pathfinder:=0, integrationPath:=[], name:="")  -> Any
{
  Computes the Picard Fuchs equations for each of a convenient base of forms over the family (1-t)*f0+t*f1. The initial conditions are expressed in the grevlex cohomology basis of f0. Writes to file everything needed to start integrating these initial value problems.
}
  B:=CompatibleCohomologyBasis(f0,f1 : pole_order_bound:=pole_order_bound);
  t0:=Cputime();
  ODEs:=PicardFuchs(B,f0,f1 : family_number:=family_number);
  t1:=Cputime();

  // setting up integration paths, unless specified
  avoid:=[];
  if #integrationPath eq 0 then
    // we will use the pathfinder algorithm specified by the integer pathfinder
    integrationPath,avoid:=SetupIntegrationPath(f0,f1,pathfinder);
  end if;

  if IsFermat(f0) then
    A0:=FermatCohomologyBasis(f0);
  else
    A0:=ComputeCohomologyBasis(f0 : order:="grevlex"); 
  end if;

  for i in [1..#ODEs] do
    requiredDerivatives := LocalBasis(ODEs[i]);
    L:=ComputeDerivatives(B[i],f0,f1,requiredDerivatives : withFactorial:=true);
    init:=CoordinatesInReducedCohomologyBasis(f0,A0,L);
    ode_filename:="IVP-"*suffix(family_number,max_number)*"-"*suffix(i,#ODEs)*".sage";
    WriteInsideTempFolder(ode_filename,"ode="*Sprint(ODEs[i]) : Overwrite:=true,name:=name);
    WriteInsideTempFolder(ode_filename,"init="*Sprint(init):name:=name);
    //WriteInsideTempFolder(ode_filename,"precision="*Sprint(E`precision):name:=name);
    WriteInsideTempFolder(ode_filename,"path="*Sprint(integrationPath):name:=name);
    WriteInsideTempFolder(ode_filename,"label=("*Sprint(family_number)*","*Sprint(i)*")":name:=name);
  end for;
  
  filename:="BaseChange-"*suffix(family_number,max_number)*".sage"; 
  if pole_order_bound eq 0 then
    // now compute grevlex basis A on f1 and compute the change of basis matrix from B to A
    A1:=ComputeCohomologyBasis(f1 : order:="grevlex"); 
    // the following matrix computes the matrix whose rows store the coordinates of entries in A1 in terms of the basis B 
    M:=CoordinatesInCohomology(f1,B,A1);
    WriteInsideTempFolder(filename,"change_coordinates=Matrix("*Sprint(#B)*","*Sprint(Eltseq(M))*")" : Overwrite:=true,name:=name);
  else 
    // we don't have to change coordinates to a standard basis because this clause can be activated only if we are at the final hypersurface
    WriteInsideTempFolder(filename,"change_coordinates=identity_matrix("*Sprint(#B)*")" : Overwrite:=true,name:=name);
  end if;

  return B;

end intrinsic;



//************************************************************************************************
//
// Stuff....
//
//************************************************************************************************


intrinsic LatticeOfRelations(periodMatrix,precision::RngIntElt : offset:=20, Delta:=0.9999, Eta:=0.5001, DeepInsertions:=false, Proof:=false, ForceRelation:=false) -> RngIntElt, SeqEnum
{
  Takes a matrix of complex numbers, typically periods. Provided there is sufficient precision, it computes the rank of the lattice of relations and an LLL reduced basis.
}

  v:=periodMatrix;
  CC<I>:=ComplexField(Precision(v[1,1]));

  precision:=precision-5;

  if offset gt 0.2*precision then
    offset:=Round(0.2*precision);
  end if;

  offsetPrecision:=offset;
  innerProduct:=IdentityMatrix(Integers(),NumberOfColumns(v));
  //innerProduct:=intmat;

  offsetV:=10^(precision-offsetPrecision) * v;
  Vr := [[Integers() | Round(Real(entry)) : entry in row] : row in RowSequence(offsetV)];
  Vi := [[Integers() | Round(Imaginary(entry)) : entry in row] : row in RowSequence(offsetV)];

  V:= Vr cat Vi;

  V:= Matrix(V)*innerProduct;
  VT:=10^3*Transpose(V);
  r:=NumberOfRows(VT);
  c:=NumberOfColumns(VT);
  id:=IdentityMatrix(Integers(),r);
  W:=HorizontalJoin(VT,id);
  print "Performing LLL -- this may take some time.";
  // this could be slow, but should be reliable
  time LW,B:=LLL(W:Delta:=Delta,Eta:=Eta,DeepInsertions:=DeepInsertions,Proof:=false);
  print "Lattice reduction completed.";
  //LW,B:=LLL(W:Method:="Integral");

  // Checking relations with higher precision that was kept from LLL
  Bt:=Transpose(B);
  preciseVV:=10^precision * v;
  VVr := Matrix([[Integers() | Round(Real(entry)) : entry in row] : row in RowSequence(preciseVV)]);
  VVi := Matrix([[Integers() | Round(Imaginary(entry)) : entry in row] : row in RowSequence(preciseVV)]);

  realError:=B*Transpose(innerProduct)*Transpose(VVr);
  imagError:=B*Transpose(innerProduct)*Transpose(VVi);

  // Reorder for better presentation
  total_norm:=[ Norm(B[i])+Norm(realError[i])+Norm(imagError[i]) : i in [1..Nrows(B)]];
  copy1:=total_norm;
  copy2:=total_norm;
  copy3:=total_norm;
  B:=RowSequence(B);
  realError:=RowSequence(realError);
  imagError:=RowSequence(imagError);
  ParallelSort(~copy1,~B);
  ParallelSort(~copy2,~realError);
  ParallelSort(~copy3,~imagError);
  B:=Matrix(B);
  realError:=Matrix(realError);
  imagError:=Matrix(imagError);

  // decide which relations are acceptable, if we trust our precision 100%!
  goodRelations:=[];
  for i in [1..Nrows(B)] do
    roundingError:=Sqrt(Norm(realError[i])+Norm(imagError[i]));
    // an honest relation can lead to an error only as an artifact of rounding, this we control by the following inequality
    if roundingError lt 1/2*Sqrt(r*c)*Sqrt(Norm(B[i])) then
      Append(~goodRelations,B[i]);
    end if;
  end for;

  print "\nNumber of relations appear to be", Sprint(#goodRelations)*".\n";
  print "Check to see if this makes sense.", "Norms of relations are listed on first row.", "Norms of the errors of these relations are listed on the second row.\n";

  errorField:=RealField(1);
  zeroRowLength:=#Sprint(Nrows(B));
  firstRowLength:=Maximum([#Sprint(errorField!Sqrt(Norm(B[j]))) : j in [1..Nrows(B)]]);

  j:=1;
  //num:=&*[" " : i in [1..(zeroRowLength-1)]]*"1";
  //print num,"||", "---hyperplane section---";
while (j le Nrows(B)) do
    num:=Sprint(j);
    if #num lt zeroRowLength then
      num:=&*[" " : i in [1..(zeroRowLength-#num)]]*num;
    end if;
    rowOne:=Sprint(errorField!Sqrt(Norm(B[j])));
    whiteSpace:=&*[" " : i in [0..(firstRowLength-#rowOne)]];
    print num, "||", rowOne*whiteSpace, "   ", errorField!Sqrt(Norm(realError[j])+Norm(imagError[j]));
    j:=j+1;
end while;
  print "\n";

  rho:=#goodRelations;
  if ForceRelation and (rho eq 0) then
    rho:=1;
  end if;

  basis:=RowSequence(B)[1..rho];

  return rho,basis;
end intrinsic;

intrinsic PhamBasis(n::RngIntElt,d::RngIntElt : CheckIfExists:=true) -> SeqEnum
{
  Computes a Pham basis for the Fermat of degree d and dimension n.
}
// X is a hypersurface in P^(n+1) of degree d
// output always contains 0's on the last entries

  
  filename:=PeriodSuiteStorageDir()*"pham-"*Sprint(n)*"-"*Sprint(d);
  if CheckIfExists and (System("test -e "*filename) eq 0) then 
    print "Reading the Pham basis from file.";
    basis:=[];
    file:=Open(filename,"r");
    beta:=Gets(file);
    while not IsEof(beta) do
      Append(~basis,eval(beta));
      beta:=Gets(file);
    end while;
    return basis;
  end if; 
    


  vars:=n+1;
  deg:=d;
  P<[x]>:=PolynomialRing(Rationals(),vars,"grevlex");
  x[#x + 1] := &*x;

  R<[y]>:=P/Ideal([&+[v^(r-1) : r in [1..deg]] : v in x]);
  V,psi:=VectorSpace(R);
  phi:=Inverse(psi);
  
  return [Append(Exponents(b),0) : b in phi(Basis(V))];
end intrinsic;


// Theorem 1.3 of Shimada
// note that beta's always have 0 at the last entry
// and this entry should be dropped when using these formulas
intrinsic cap(beta1::[RngIntElt],beta2::[RngIntElt],d::RngIntElt) -> RngIntElt
{
  Intersects the two Pham cycles corresponding to beta1 and beta2 in Fermat of degree d.
}
  N := #beta1; // N := n+2;
  // take beta1 to the other side
  beta:=[ beta2[i] - beta1[i] : i in [1..N]];
  //Changing from their coordinates to mine requires a translation
  g:=SymmetricGroup(N)!([N] cat [1..(N-1)]);
  beta:=PermuteSequence(beta,g);
  // divide by the action on the last coordinate, everything is modulo d
  beta:=[ (beta[i] - beta[N]) mod d : i in [1..(N-1)]];
  // this is used as part of the formula
  betaShift := [ (b+1) mod d : b in beta];
  // helper function of Shimada
  eps:=func<b| case<b mod d| 0:1, 1:-1, default:0>>;
  return (-1)^(Integers()!((N-2)*(N-1)/2)) * (&*[eps(b) : b in beta] - &*[eps(b) : b in betaShift]);
end intrinsic;

// intersection matrix for pham cycles
intrinsic PhamIntersectionMatrix(n::RngIntElt,d::RngIntElt) -> SeqEnum
{
  Computes a Pham basis for Fermat of degree d and n together with its intersection matrix.
}
  B := PhamBasis(n,d);
  return Matrix([[cap(beta1,beta2,d) : beta2 in B] : beta1 in B]), B;
end intrinsic;

// intersection matrix for pham cycles, from basis
intrinsic PhamIntersectionMatrixFromBasis(B::SeqEnum,d::RngIntElt) -> SeqEnum
{
  Takes a Pham basis for Fermat of degree d and returns the intersection matrix.
}
  return Matrix([[cap(beta1,beta2,d) : beta2 in B] : beta1 in B]);
end intrinsic;


intrinsic integrateMonomials(alphas::SeqEnum,degree::RngIntElt,phamBasis::SeqEnum : type:=[], precision:=20) -> SeqEnum
{
  Takes a list of exponents (shifted by +1) of monomials. Integrates over phamBasis of Fermat of degree d.
}
  d:=degree;
  n:=#(alphas[1])-2;
  if #type eq 0 then 
    type := Append([1 : i in [1..(n+1)]],-1); 
  end if;
  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);
  xi := Exp(2*Pi(CC)*I/d); // d-th root of unity
  rootsOfType:=[Root(CC!type[i],d) : i in [1..(#type-1)]] cat [Root(CC!(-type[#type]),d)];


  // setting up the "empty" list
  integrals:=[[CC|0 : beta in phamBasis] : alpha in alphas];
  // store computed gamma values for efficiency
  gammaValues:=[CC|0 : i in [1..5000]];
  for u in [1..#alphas] do
    //printf "\nIntegrating monomial number %o out of %o", u, #alphas;
    alpha:=alphas[u];
    l:=Integers()!((&+alpha)/d);
    // Default to the standard fermat type
    alphaX := alpha[1..(n+1)];
    ax:=alpha[n+2];

    prod:= &*([1] cat [ax-j*d : j in [1..(l-1)]]);
    c_dla:= (-1)^l/(Factorial(l-1) * d^l) * prod;

    vals:=alphaX cat [&+[a : a in alphaX]];
    for a in vals do
      if (not IsDefined(gammaValues,a)) or (gammaValues[a] eq 0) then
        gammaValues[a]:=Gamma(CC!(a/d));
      end if;
    end for;
    //printf "\n";

    mainTerm:= (-1/d)^n*&*[(1-xi^(-a))*gammaValues[a] : a in alphaX]/gammaValues[&+[a : a in alphaX]];

    // depending on the Fermat type we have to scale
    scl := 1/( &*[rootsOfType[j]^alpha[j] : j in [1..#alpha]]);
    dotProd:=func<beta |&+[alpha[j]*beta[j] : j in [1..(n+1)]]>;

    integrals[u]:=[scl*c_dla*xi^dotProd(beta)*mainTerm : beta in phamBasis];
  end for;

  return integrals;

end intrinsic;

intrinsic norm(l,m) -> Any
{
  Computes the norm of a vector l with respect to the inner product given by the matrix m.
}
  return (Matrix(l)*m*Transpose(Matrix(l)))[1,1];
end intrinsic;

intrinsic inner(l1,m,l2) -> Any
{
  Computes the inner product of vectors l1 and l2 with respect to the matrix m.
}
  return (Matrix(l1)*m*Transpose(Matrix(l2)))[1,1];
end intrinsic;

// find all vectors of norm N and degree between d1 and d2 in a lattice with polarization
// the orthogonal complement of the polarization is assumed negative definite
intrinsic LatticeElementsOfNormAndDegree(lattice::AlgMatElt,polarization::ModMatRngElt,N::RngIntElt,d1::RngIntElt,d2::RngIntElt) -> Any
{
 lattice is an intersection matrix on ZZ^rho. Polarization is an element in ZZ^rho. The orthogonal complement of polarization is assumed to be negative definite. For an element D in ZZ^rho, D^2 is norm and D dot polarization is degree. Find all vectors of norm N and degree between d1 and d2.
}

  // rank of lattice
  rho:=Ncols(lattice);
  //basis
  id:=IdentityMatrix(Integers(),rho);
  // degree of polarization 
  d:=norm(polarization,lattice);

  // projection map (scaled by d)
  // d*id - lattice*polarization
  proj:=Matrix([ d*e - inner(e,lattice,polarization)*polarization[1] : e in Rows(id) ]);
  basis:=Matrix(Basis(RowSpace(proj)));
  prim:=-basis*lattice*Transpose(basis);
  //gcd:=GCD(Eltseq(prim));
  //primReduced:=Matrix(rho-1,rho-1, [Integers()|p/gcd : p in Eltseq(prim)]);
  L:=Lattice(IdentityMatrix(Integers(),Nrows(basis)),prim);

  all_curves:=[**];
  for i in [d1..d2] do
    // norm of the projection of an element of norm N and degree i is kappa (because of scaling)
    kappa:=d*(-d*N+i^2); 
    if IsIntegral(kappa) then
      kappa:= Integers()!kappa;
      sv:=ShortVectors(L,kappa,kappa);
    else
      sv:=[];
    end if;
    // add or subtract polarization
    candidates:=[ Matrix(s[1])*basis + i*polarization: s in sv] cat [ Matrix(s[1])*basis - i*polarization : s in sv];
    // check the ones that would be integral even after dividing by d
    divisible:=[ Vector(l) : l in candidates | GCD(Eltseq(l)) mod d eq 0 ];
    // now fix the signs of non-effective classes
    finalists:=[];
    for l in divisible do
      if inner(l,lattice,polarization) eq d*i then
        Append(~finalists,l);
      else
        Append(~finalists,-l);
      end if;
    end for;

    // in case of duplicates, we trim them
    trim:=Seqset(finalists);

    // now divide 
    curves:=[ Vector([Integers()!(e/d) : e in Eltseq(l) ])  : l in trim];
    Append(~all_curves,curves);
  end for;

  return all_curves;
end intrinsic;


intrinsic MinimalPolynomials(pers::SeqEnum : precision:=500, max_order:=30) -> Any,Any,Any//[RngUPolElt],[FldReElt],[RngIntElt]
{
  Takes a sequence of complex numbers each of which are suspected to approximate an algebraic number to much more than "precision" number of digits. The first output is the list of suspected minimal polynomials of the corresponding algebraic numbers. Second output is the list of norms of these polynomials evaluated at the corresponding approximate number. The third list contains a list of indices where the given polynomial is likely to be wrong.
}
  position:=0;
  polys:=[];
  bad:=[];
  errs:=[RealField(1)|];
  CC<I>:=Parent(pers[1]);
  T<t>:=PolynomialRing(Rationals());
  for p in pers do
    position +:= 1;
    print "position: ", position;
    //print "norm: ", Sqrt(Norm(p));
    //if position ne 2 then continue; end if;
    if Norm(p) lt 10^-(precision) then 
      Append(~polys,T!0);
      continue;
    end if;
    rr:=Sqrt(Norm(p));
    significand,exponent:=ScientificNotation(rr);
    r:=CC!(p/(significand*10^exponent));
    //r:=p/Sqrt(Norm(p));
    m:=Matrix([[r^i : i in [0..max_order]]]);
    _,rels:=LatticeOfRelations(m,precision : offset:=Ceiling(precision/10), ForceRelation:=true);
    _,best_relation_no:=Minimum([Maximum([ j : j in [1..#rels[i]] | rels[i,j] ne 0]) : i in [1..#rels]]);
    rel:=rels[best_relation_no];
    pol:=&+[ rel[i]*t^(i-1) : i in [1..#rel]];
    factors:=[fctr[1] : fctr in Factorization(pol)];
    evals:=[RealField(1)| Norm(Evaluate(fctr,r)) : fctr in factors];
    ParallelSort(~evals,~factors);
    //pol:=Evaluate(factors[1],t*(significand*10^exponent));
    // clear denominators
    pol:=Evaluate(factors[1],T.1/(significand*10^exponent));
    pol:=ClearDenominatorsOfPolynomial(pol);
    Append(~polys,pol);
    Append(~errs,Sqrt(Norm(Evaluate(pol,p))));
    if #rels eq 1 then Append(~bad,position); end if;
  end for;

  return polys, errs, bad;
end intrinsic;


intrinsic ScientificNotation(r::FldReElt : base:=10) -> RngIntElt, RngIntElt
{
  Takes a real number r and returns a rational significand u and exponent e such that r is approximately u*base^e.
}
  pr:=Sign(r)*r;
  flip:=(pr lt 1);
  if flip then
    pr:=1/pr;
  end if;
  i:=0;
  while pr gt base^(i+1) do
    i +:= 1;
  end while;
  if flip then
    i:=-i;
  end if;
  return Round(r*base^(-i+3))*base^-3,i;
end intrinsic;

intrinsic ClearDenominatorsOfPolynomial(pol::RingUPolElt) -> RngUPolElt
{
  Clears the denominators of the input polynomial. The coefficients may be from any field where "ClearDenominator" works.
}
  T:=Parent(pol);
  cofs:=Eltseq(ClearDenominator(Matrix([Coefficients(pol)])));
  gcd:=GCD(cofs);
  new_cofs:=[ c/gcd : c in cofs];
  return T!Polynomial(new_cofs);
end intrinsic;

intrinsic suffix(number::RngIntElt,  max_number::RngIntElt) -> MonStgElt
{
  Creates a string containing number with the right number of trailing zeros to be able to write max_number.
}
  digits:=(max_number gt 0) select #Sprint(max_number) else #Sprint(number); 
  return Sprint(10^digits+number)[2..(digits+1)];
end intrinsic;

intrinsic WriteIVPsToFile(E::Rec : number:=0, max_number:=0, name:="", singular_locus:=false)
{
  Writes the output of ConstructIVPs in a format readable by Sage.
}
  // transition functions
  filename:="BaseChange-"*suffix(number,max_number)*".sage"; 
  M:=E`changeBasis;
  nrows:=Nrows(M);
  if IsIdentity(M) then
    WriteInsideTempFolder(filename,"change_coordinates=identity_matrix("*Sprint(nrows)*")" : Overwrite:=true,name:=name);
  else
    WriteInsideTempFolder(filename,"change_coordinates=Matrix("*Sprint(nrows)*","*Sprint(Eltseq(M))*")" : Overwrite:=true,name:=name);
  end if;
  //WriteInsideTempFolder(filename,"singularities="*Sprint(E`pointsToAvoid):name:=name);
  
  for i in [1..#E`ODEs] do
    ode_filename:="IVP-"*suffix(number,max_number)*"-"*suffix(i,#E`ODEs)*".sage";
      
    WriteInsideTempFolder(ode_filename, "ode="  *Sprint(E`ODEs[i])  : Overwrite:=true,name:=name);
    WriteInsideTempFolder(ode_filename, "init=" *Sprint(E`inits[i]) : name:=name);

    //WriteInsideTempFolder(ode_filename,"precision="*Sprint(E`precision):name:=name);

    WriteInsideTempFolder(ode_filename, "path="   *Sprint(E`integrationPath)        : name:=name);
    WriteInsideTempFolder(ode_filename, "label=(" *Sprint(number)*","*Sprint(i)*")" : name:=name);
    WriteInsideTempFolder(ode_filename, "loop_position=" *Sprint(E`loop_position)   : name:=name);

    if Type(singular_locus) ne BoolElt then
      WriteInsideTempFolder(ode_filename,"singular_locus="*Sprint(singular_locus) : name:=name);
    end if;
  end for;

  // not required
  //filename2:="IVPs-meta-"*suffix;
  //WriteInsideTempFolder(filename2, Sprint(E`t) : Overwrite:=true,name:=name);
  //WriteInsideTempFolder(filename2, Sprint(E`analytics):name:=name);
  //WriteInsideTempFolder(filename2,"movingBasis="*Sprint(E`movingBasis):name:=name);

end intrinsic;




// X a hypersurface Z(f) in P^(n+1)
// equation: f
// dimension: n
// degree: deg X
// primitivePeriods: (primitive) period matrix of X wrt phamBasis and cohomBasis deformed via data from misc
// periods:  period matrix of X, completed from the primitive matrix by the addition of a "linear" class
// primitiveIntersectionMatrix: intersection product on primitive homology wrt to the phamBasis and cohomBasis
// intersectionMatrix: extension of primitive intersection matrix by the addition of a linear class to Fermat
// precision: the precision for which the period matrix is known to be correct
// polarization: coordinates of the hyperplane class wrt the basis of homology
// hodgeLattice: (virtual) Hodge lattice, computed from the period matrix and the linear class
// lat: shorthand for X`hodgeLattice`lattice
// pol: shorthand for X`hodgeLattice`polarization (this is different from polarization above)
// loopBegins,loopEnds: the periods of a hypersurface near the singular target hypersurface, before and after a looping around the target
// primitiveToComplete: transition matrix for converting primitive periods to complete periods
// monodromy: if bundle is obtained from a singular target, this will store the monodromy operator of going around the singular fiber in the last family.
PeriodBundle := recformat<equation,degree,dimension,primitivePeriods, periods,loopBegins,loopEnds, phamBasis, cohomBasis,primitiveToComplete,primitiveIntersectionMatrix,intersectionMatrix,monodromy,precision,odes,deformation,hodgeLattice,polarization, lat,pol, name>;

intrinsic DimensionOfMiddleCohomology(dim::RngIntElt,deg::RngIntElt) -> RngIntElt
{
  The dimension of the middle cohomology H^dim of a smooth hypersurface of degree "deg" and dimension "dim".
}
  return  &+[(-1)^i*Binomial(dim+2,i)*deg^(dim+1-i) : i in [0..dim]] + (-1)^(dim+1)*2*Floor(dim/2);
end intrinsic;

intrinsic HasAllPeriods(X::Rec) -> BoolElt
{
  Checks if the complete period matrix for X has been computed.
}
  if (X`dimension mod 2) eq 0 then
    return Ncols(X`periods) eq (Nrows(X`periods)+1);
  else 
    return Ncols(X`periods) eq Nrows(X`periods);
  end if;
end intrinsic;

intrinsic PeriodHomotopy(f::RngMPolElt : precision:=100, straight:=false, bound_pole_order:=true, randomizePath:=true, pathfinder:=0, reduce_initials:=true, name:="", overwrite:=false, integrate:=true) -> Any
{ Computes the periods of the hypersurface Z(f). }

  if straight then
    path:=[BestFermat(f),f];
  else  
    path:=BreakingPath(f : randomize:=randomizePath); 
  end if;

  return PeriodHomotopy(path : precision:=precision, bound_pole_order:=bound_pole_order, pathfinder:=pathfinder, reduce_initials:=reduce_initials, name:=name, overwrite:=overwrite, integrate:=integrate);
end intrinsic;

intrinsic PeriodHomotopy(path::[RngMPolElt] : precision:=100, straight:=false, bound_pole_order:=true, pathfinder:=0, integrationPaths:=[], reduce_initials:=true,name:="",overwrite:=false,integrate:=true) -> Any
{
  Computes the periods of the hypersurface appearing as the last entry of "path". First all the periods of intermediate hypersurfaces in order to reach the target hypersurface.
}

  if #path eq 1 then return PeriodHomotopy(path[1] : precision:=precision, straight:=straight, bound_pole_order:=bound_pole_order,pathfinder:=pathfinder, reduce_initials:=reduce_initials, name:=name, overwrite:=overwrite,integrate:=integrate); end if;

  if not IsFermat(path[1]) then
    error "The initial polynomial is not of fermat type." ;
  end if;

  beginningTime:=Realtime();
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  CheckIfIVPDirectoryExists(name, ivpdir, overwrite);

  WriteMetaFile(name, precision, path, reduce_initials : first_of_path_is_fermat:=true);
  /* WriteInsideTempFolder("meta.sage","precision="*Sprint(precision):name:=name); */
  /* WriteInsideTempFolder("meta.sage","d="*Sprint(Degree(path[1])):name:=name); */
  /* WriteInsideTempFolder("meta.sage","fermat_type="*Sprint(Coefficients(path[1])):name:=name); */
  /* WriteInsideTempFolder("meta.sage","reduce="*Sprint(reduce_initials):name:=name); */
  
  // either the right number of integrationPaths should be provided, or none at all
  if #integrationPaths eq 0 then integrationPaths:=[[] : i in [1..(#path-1)]]; end if;
  assert #integrationPaths eq #path-1; 


  target:=path[#path]; 
  target_is_smooth:=isSmooth(target);
  P:=Parent(target);
  n:=Ngens(P)-2;
  d:=Degree(target); 
  if d eq 1 then
    error "Degree of the hypersurface needs to be greater than one.";
  end if;

  // bounding the pole order of cohomology classes for the target hypersurface accelerates the procedure, while providing complete information on the Hodge decomposition
  // but we can only bound pole order, if there is non-zero classes outside of H^{n/2,n/2}
  if Ceiling(n/2)*d-Ngens(P) lt 0 then bound_pole_order:=false; end if;
  pole_order_bound:=bound_pole_order select Ceiling(n/2) else 0;

  allODEs:=[];
  tstart:=Realtime();
  for i in [1..(#path-1)] do
    print "\n\n************************************\nWe are at family number",i,"out of",#path-1,"\n************************************\n";
    if i ne (#path-1) then
      pob:=0; // pole order bound
      f1_is_smooth:=true;
    else
      pob:=pole_order_bound; // in the last step we need only compute some of the periods
      f1_is_smooth:=target_is_smooth;
    end if;
      ivps:=ConstructIVPs(path[i],path[i+1] : pathfinder:=pathfinder, family_number:=i, integrationPath:=integrationPaths[i], pole_order_bound:=pob, reduce_initials:=reduce_initials,precision:=precision, f1_is_smooth:=f1_is_smooth);
      Append(~allODEs,ivps`ODEs);

      WriteIVPsToFile(ivps : number:=i, max_number:=#path-1, name:=name);
    // to parallelize one could start integration at this point, or even sooner for each IVP
  end for;

  print "\n\nIf this is the first time, we will compute a Pham basis for the Fermat hypersurface of degree", d, "and dimension", n;
  // intmat is not urgent, but phamB is recorded for sage to use
  phamB,intmat:=WriteToFileHomAndCohOfFermat(n,d); 
  // define a period bundle
  bundle:=rec<PeriodBundle | equation:=path[#path],dimension:=n,degree:=d, primitiveIntersectionMatrix:=Matrix(intmat),phamBasis:=phamB,
  odes:=allODEs,
  deformation:=path, cohomBasis:=ivps`movingBasis,
  name:=name
  >;
  printf "\nComputation of the differential equations is now complete (%o seconds).\n\n", Realtime()-tstart;


  // Integration may crash. Save everything up until this point.
  if #name gt 0 then SaveBundle(bundle); end if;

  ////////////////////////////////////////
  /// Integration happens here ///////////
  ////////////////////////////////////////
  if integrate then
    print "Starting integration.\n\n";
    bundle:=SolveIVPs(bundle);
  end if;
  ////////////////////////////////////////
  ////////////////////////////////////////

  pathMons:=[#Monomials(p) : p in path];
  pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];
  print "Used the following path:",path;
  print "The number of monomials appearing at each step:\n",pathMons;
  print "The number of monomials changed at each step:\n",pathMonsChange;

  return bundle, ivpdir;
end intrinsic;


//****************************************
// TransitionHomotopy Section.

// Input: f0,f1
// Output: A list of polynomials whose roots specify the values of t
// for which (1-t)*f0 + t*f1 is singular. Usually this is just the list [1].
//
function SingularLocusInFamily(f0,f1)
    P := Parent(f0);
    R<t> := PolynomialRing(Rationals(), Ngens(P)+1, "elim", 1);
    inc := hom<P->R|[R.i : i in [2..Ngens(R)]]>;
    
    F  := (1-t)*inc(f0)+t*inc(f1);
    I  := ideal<R|[Derivative(F,i): i in [2..Ngens(R)]]>;
    J  := ideal<R|[R.i : i in [2..Ngens(R)]]>;

    IJ := Saturation(I,J);
    gb := GroebnerBasis(IJ);
    polys :=[p : p in gb | IsUnivariate(p,t)];
    return polys;
end function;

intrinsic TransitionHomotopy(path::[RngMPolElt] :
			     alarm:=0,
			     precision:=100, straight:=false,
			     bound_pole_order:=false,
			     pathfinder:=0, integrationPaths:=[],
			     reduce_initials:=true, name:="",
			     overwrite:=false, integrate:=true) -> Any
{
    Computes the transition matrices needed to carry periods from paths[1] to paths[#paths].
}
  // NOTE: integration paths here means the list of quartics to get from start to finish,
  //       instead of the real contor inside a P1 used to compute the transition matrices.

  if #path eq 1 then
    error "Transition Homotopy needs start and endpoint as input. Perhaps you meant PeriodHomotopy?";
  end if;

  beginningTime:=Realtime();
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  CarefulInitializeIVPDirectory(name, ivpdir, overwrite);
  WriteMetaFile(name, precision, path, reduce_initials);
    
  // either the right number of integrationPaths should be provided, or none at all
  if #integrationPaths eq 0 then integrationPaths:=[[] : i in [1..(#path-1)]]; end if;
  assert #integrationPaths eq #path-1; 


  target:=path[#path]; 
  target_is_smooth:=isSmooth(target);
  P:=Parent(target);
  n:=Ngens(P)-2;
  d:=Degree(target); 
  if d eq 1 then
    error "Degree of the hypersurface needs to be greater than one.";
  end if;

  // bounding the pole order of cohomology classes for the target hypersurface accelerates
  // the procedure, while providing complete information on the Hodge decomposition
  // but we can only bound pole order, if there is non-zero classes outside of H^{n/2,n/2}
  if Ceiling(n/2)*d-Ngens(P) lt 0 then bound_pole_order:=false; end if;
  pole_order_bound:=bound_pole_order select Ceiling(n/2) else 0;

  allODEs:=[];
  tstart:=Realtime();
  for i in [1..(#path-1)] do
      vprint PicardFuchs : "\n\n************************************\nWe are at family number",i,
	    "out of",#path-1,"\n************************************\n";

      pob:=0; // pole order bound
      f1_is_smooth:=target_is_smooth;
      if i eq (#path-1) then
        pob:=pole_order_bound;
      else
        pob:=false;
      end if;
      
      ivps:=ConstructIVPs(path[i],path[i+1] :
			  alarm:=alarm,
			  pathfinder:=pathfinder, family_number:=i,
			  integrationPath:=integrationPaths[i],
			  pole_order_bound:=pob,
			  reduce_initials:=reduce_initials,
			  precision:=precision,
			  f1_is_smooth:=f1_is_smooth);
      
      Append(~allODEs,ivps`ODEs);

      slocus := SingularLocusInFamily(path[i],path[i+1]);
      WriteIVPsToFile(ivps : number:=i, max_number:=#path-1,
			     name:=name, singular_locus := slocus);

  end for;

  // define a period bundle
  bundle:=rec<PeriodBundle | equation:=path[#path],dimension:=n,degree:=d,
			     primitiveIntersectionMatrix:="", phamBasis:="",
			     odes:=allODEs,
			     deformation:=path, cohomBasis:=ivps`movingBasis,
			     name:=name >;
  vprintf PicardFuchs : "\nComputation of the differential equations is now complete (%o seconds).\n\n",
	 Realtime()-tstart;


  // Integration may crash. Save everything up until this point.
  if #name gt 0 then SaveBundle(bundle); end if;


  ////////////////////////////////////////
  /// Integration happens here ///////////
  ////////////////////////////////////////
  if integrate then
    vprint PicardFuchs : "Starting integration.\n\n";
    bundle:=SolveTransitionIVPs(bundle);
  end if;
  ////////////////////////////////////////
  ////////////////////////////////////////

  pathMons:=[#Monomials(p) : p in path];
  pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];
  vprint PicardFuchs, 2 : "Used the following path:",path;
  vprint PicardFuchs, 2 : "The number of monomials appearing at each step:\n",pathMons;
  vprint PicardFuchs, 2 : "The number of monomials changed at each step:\n",pathMonsChange;

  return bundle, ivpdir;
end intrinsic;

intrinsic SolveTransitionIVPs(bundle::Any) -> Any
{
    Takes as input the name of the initial value problems which have been saved in storage directory and integrates them. This version takes the period bundle, which is faster than loading in from file.
}
  name:=bundle`name;
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  error_code:=CallIntegrator("transition-integrator.sage", ivpdir);
  return bundle;
end intrinsic;


//****************************************  End TransitionHomotopy Section.

intrinsic SolveIVPs(name::MonStgElt) -> Any
{
  Takes as input the name of the initial value problems which have been saved in storage directory and integrates them.
}

  bundle:=LoadBundle(name : withPeriods:=false);

  return SolveIVPs(bundle);

end intrinsic;

intrinsic SolveIVPs(bundle::Any) -> Any
{
  Takes as input the name of the initial value problems which have been saved in storage directory and integrates them. This version takes the period bundle, which is faster than loading in from file.
}
  name:=bundle`name;
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  error_code:=CallIntegrator("integrator.sage", ivpdir);
  
  if isSmooth(bundle`equation) then
    bundle`primitivePeriods,bundle`precision:=loadPeriods(ivpdir*"periods");
    bundle:=PrimitiveToComplete(bundle);
    bundle`periods:=bundle`primitivePeriods*ChangeRing(bundle`primitiveToComplete,Parent(bundle`primitivePeriods[1,1]));
  else
    bundle`loopBegins:=loadPeriods(ivpdir*"periods1");
    // precision is worst at the end
    bundle`loopEnds,bundle`precision:=loadPeriods(ivpdir*"periods2");
    bundle`periods:=loadPeriods(ivpdir*"limit_periods");
    bundle:=PrimitiveToComplete(bundle);
  end if;

  print "The periods are correct to "*Sprint(bundle`precision)*" digits.";
  if bundle`precision lt 20 then
    print "Low precision is often caused by poor *integration* paths. Try the computation again or input your own integration paths for better results.";
  end if;

  return bundle;

end intrinsic;


intrinsic LoadBundle(name::MonStgElt : withPeriods:=true) -> Any
{
  Reads the "bundle" file written under the storage directory with the given name, construct the corresponding PeriodBundle and returns it.
}

  ivpdir:=IVPWorkingDir(:subfolder:=name);
  filename:=ivpdir*"bundle";
  file:=Open(filename,"r");
  bundle:=rec<PeriodBundle | name:=name >;
  poly:=func<cofs,exps,polyring | &+[ cofs[i]*Monomial(polyring,exps[i]) : i in [1..#cofs]]>;
  field:=eval(Gets(file));
  N:=eval(Gets(file));
  varnames:=eval(Gets(file));
  P:=PolynomialRing(field,N);
  AssignNames(~P,varnames);
  cofs:=eval(Gets(file));
  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  exps:=eval(str);
  bundle`equation:=poly(cofs,exps,P);
  bundle`degree :=Degree(bundle`equation);
  bundle`dimension :=N-2;
  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  cofs:=eval(str);
  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  exps:=eval(str);
  bundle`cohomBasis :=[poly(cofs[i],exps[i],P) : i in [1..#cofs]];
  phamB,intmat:=WriteToFileHomAndCohOfFermat(bundle`dimension,bundle`degree);
  bundle`phamBasis:=phamB; bundle`primitiveIntersectionMatrix:=Matrix(intmat);

  K<t>:=FunctionField(field);
  RR<D>:=PolynomialRing(K); 
  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  bundle`odes:=eval(str);

  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  cofs:=eval(str);
  str:="";
  for i in [1..eval(Gets(file))] do
    str *:= Gets(file);
  end for;
  exps:=eval(str);
  bundle`deformation :=[poly(cofs[i],exps[i],P) : i in [1..#cofs]];

  if withPeriods then 
    periodsExist:=System("[ -f "*ivpdir*"periods ]") eq 0;
    loopPeriodsExist:=System("[ -f "*ivpdir*"periods1 ]") eq 0;
    if (periodsExist or loopPeriodsExist) then
      target_is_smooth:=isSmooth(bundle`equation);
      if target_is_smooth and periodsExist then
        bundle`primitivePeriods,bundle`precision:=loadPeriods(ivpdir*"periods");
        bundle:=PrimitiveToComplete(bundle);
        bundle`periods:=bundle`primitivePeriods*ChangeRing(bundle`primitiveToComplete,Parent(bundle`primitivePeriods[1,1]));
      elif (not target_is_smooth) and loopPeriodsExist then
        bundle`loopBegins:=loadPeriods(ivpdir*"periods1");
        // precision is worst at the end
        bundle`loopEnds,bundle`precision:=loadPeriods(ivpdir*"periods2");
        bundle`periods:=loadPeriods(ivpdir*"limit_periods");
        bundle:=PrimitiveToComplete(bundle);
      end if;
    end if;
  end if;

  return bundle;

end intrinsic;


intrinsic SaveBundle(periodBundle::Any, name::MonStgElt)
{
  Saves the state of a period bundle prior to the integration of IVPs into the storage directory into the folder "name".
}
  periodBundle`name:=name;
  SaveBundle(periodBundle);
end intrinsic;

intrinsic SaveBundle(periodBundle::Any)
{
  Saves the state of a period bundle prior to the integration of IVPs into the storage directory into a folder named after the name of the bundle (bundle`name).
}
// if folder does not exist, creates it
// if the file inside exists, overwrites it
  cols:=GetColumns();
  SetColumns(0);
  X:=periodBundle;
  name:=X`name;
  P:=Parent(X`equation); varnames:=Names(P);
  N:=Ngens(P); field:=CoefficientRing(P);
  str:="";

  // do not change the order, unless you also change LoadBundle
  // better would have been to have a uniform way to write things to file
  // as in to say "how many lines are to be read to constitute one input"
  // and then the input
  // we do this below only where necessary

  str *:=Sprint(field,"Magma")*"\n";
  str *:=Sprint(N)*"\n";
  str *:=Sprint(varnames,"Magma")*"\n";
  cofs,mons:=CoefficientsAndMonomials(X`equation);
  exps:=[Exponents(m) : m in mons];
  str *:=Sprint(cofs,"Magma")*"\n";
  str *:=Sprint(#exps+2)*"\n";
  str *:=Sprint(exps)*"\n";
  cofs:=[Coefficients(omega) : omega in X`cohomBasis];
  exps:=[[Exponents(m) : m in Monomials(omega)] : omega in X`cohomBasis];
  str *:= Sprint(#cofs+2)*"\n";
  str *:=Sprint(cofs , "Magma")*"\n";
  str *:= Sprint(&+[#e+2 : e in exps]+2)*"\n";
  str *:=Sprint(exps)*"\n";
  str *:=Sprint(&+[#odes+2 : odes in X`odes]+2)*"\n";
  str *:=Sprint(X`odes)*"\n";
  cofs:=[Coefficients(p) : p in X`deformation];
  exps:=[[Exponents(m) : m in Monomials(p)] : p in X`deformation];
  str *:= Sprint(#cofs+2)*"\n";
  str *:=Sprint(cofs , "Magma")*"\n";
  str *:= Sprint(&+[#e+2 : e in exps]+2)*"\n";
  str *:=Sprint(exps)*"\n";

  WriteInsideTempFolder("bundle",str : name:=name, Overwrite:=true, createFolder:=true);
  SetColumns(cols);
end intrinsic;

intrinsic loadPeriods(filename::MonStgElt) -> Any, Any
{
  Parses the output of integration.
}
file:=Open(filename,"r");

  // read precision
  s:=Gets(file);
  precision:=eval s;

  // read the storage precision for the arb matrix.
  s:=Gets(file);
  CC<I>:=ComplexField(eval s);
  old_prec:=Precision(GetDefaultRealField());
  SetDefaultRealFieldPrecision(eval s);

  // Read the periods from the file.
  primitive:=[];
  s:=Gets(file);
  while not IsEof(s) do
    Append(~primitive,eval(s));
    s:=Gets(file);
  end while;

  // Resent the default real field precision.
  SetDefaultRealFieldPrecision(old_prec);

  // Return the period matrix and the precision.
  return Matrix(primitive), precision;
end intrinsic;



intrinsic isSmooth(f::RngMPolElt) -> BoolElt
{ Checks if the hypersurface defined by a homogeneous polynomial is smooth. }
 return IsNonsingular(Scheme(Proj(Parent(f)),f));
end intrinsic;

intrinsic BestFermat(g::RngMPolElt) -> RngMPolElt
{ Returns a Fermat polynomial which shares as many coefficients with the input polynomial as possible. }
  R:=Parent(g);
  d:=Degree(g); N:=Ngens(R);
  type:=[MonomialCoefficient(g,(R.i)^d) : i in [1..N]];
  zeros:=[i : i in [1..N] | type[i] eq 0];
  for i in zeros do
    type[i]:=Random(Coefficients(g));
  end for;
  return Fermat(R,d : type:=type);
end intrinsic;

intrinsic BreakingPath(g1::RngMPolElt : randomize:=false, g0:=BestFermat(g1)) -> Any
{ Returns a deformation path from BestFermat(g1) to g1.}
  steps:=[g0];
  repeat
    h:=BreakingPathAuxillary(steps[#steps],g1 : randomize:=randomize);
    Append(~steps,h);
  until h eq g1;
  return steps;
end intrinsic;

intrinsic getTerm(g::RngMPolElt,m::RngMPolElt) -> Any
{ Returns the monomial term m of g.}
  return MonomialCoefficient(g,m)*m;
end intrinsic;

intrinsic BreakingPath(g0::RngMPolElt, g1::RngMPolElt : randomize:=false) -> Any
{ Returns a deformation path from g0 to g1.}
  steps:=[g0];
  repeat
    h:=BreakingPathAuxillary(steps[#steps],g1 : randomize:=randomize);
    Append(~steps,h);
  until h eq g1;
  return steps;
end intrinsic;


intrinsic BreakingPathAuxillary(f::RngMPolElt,g::RngMPolElt : randomize:=false) -> RngMPolElt
{ Computes the next step for the BreakingPath function. }

  if f eq g then return g; end if;
  
  monsf:=Monomials(f);
  monsg:=Monomials(g);
  toSubtract:=Seqset([m: m in monsf | m notin monsg]);
  toAdd:=Seqset([m: m in monsg | m notin monsf]);
  common:=[m : m in monsg | m in monsf];
  toChange:=[m : m in common | not getTerm(f,m) eq getTerm(g,m)];

  if not #toChange eq 0 then
    if randomize then
      m:=Random(toChange);
    else
      m:=toChange[1];
    end if;
    return f - getTerm(f,m) + getTerm(g,m);
  end if;

  for j in [1..#toSubtract+#toAdd] do
    for i in [0..j] do
     subtract:=Subsets(toSubtract,j-i);
     add:=Subsets(toAdd,i);
     iterate:=[[*s,a*] : s in subtract, a in add];
     if randomize then
       shuffler:=[Random(100000) : i in [1..#iterate]];
       ParallelSort(~shuffler,~iterate);
     end if;
     for mons in iterate do
      ss:=&+([0] cat [getTerm(f,m) : m in mons[1]]);
      aa:=&+([0] cat [getTerm(g,m) : m in mons[2]]);
      h:=f-ss+aa;
      if isSmooth(h) then return h; end if;
     end for;
    end for;
  end for;

  // g is not smooth
  return g;

end intrinsic;


// f0,f1 are homogenous polynomials 
// we convert it to a family of polynomials by linear interpolation
intrinsic SetupFamily(f0::RngMPolElt,f1::RngMPolElt) -> RngMPolElt
{ Given polynomials f0,f1 return the one parameter family of polynomials (1-t)*f0-t*f1.}
  R:=Parent(f0); 
  Q:=CoefficientRing(R);
  K<t>:=FunctionField(Q);
  R<[x]> := PolynomialRing(K,Ngens(R));
  return (1-t)*(R!f0) + t*(R!f1);
end intrinsic;

intrinsic SetupIntegrationPath(f0::RngMPolElt,f1::RngMPolElt, pathfinder::RngIntElt : f1_is_smooth:=isSmooth(f1)) -> Any,Any
{
Computes a sequence of rectilinear paths in the complex plane avoiding any singular fibers in the family of hypersurfaces (1-t)*f1+t*f0.
}

  Cc:=ComplexField(10);
  AssignNames(~Cc,["I"]);

  if f1_is_smooth then
    PathFinder:=case<pathfinder| 1:PathFinder1, default:PathFinder0>;
    path,avoid:=PathFinder(f0,f1);
    avoidPoints:=planeToComplex(avoid);
    loop_position:=-1;
  else 
    path,avoid,loop_position:=FormLoop(f0,f1 : pathfinder:=pathfinder);
    avoidPoints:=avoid;
  end if;
  integrationPath := [Sprint(pt[1] + pt[2]*Cc.1) : pt in path];
  integrationPath[1]:=Sprint(0);
  //if f1_is_smooth then integrationPath[#integrationPath]:=Sprint(1); end if;
  integrationPath[#integrationPath]:=Sprint(1);
  return integrationPath,avoidPoints,loop_position;

end intrinsic;

// Returning empty lists is equivalent to returning straight paths of integration.
intrinsic PathFinder0(f0::RngMPolElt,f1::RngMPolElt) -> Any, Any
{ This function does not study the hypersurfaces but returns a predetermined path of integration. }

  V:=VectorSpace(RealField(20),2);
  p0:=V!0;
  p1:=V![1,0];

  return [p0,p1],[];
end intrinsic;


// cmlxPts is a list of points in the complex plane
// output is a list of the corresponding points in a 2 dimensional real vector space
intrinsic complexToPlane(cmplxPts::[FldComElt]:precision:=20) -> Any
{ 
  Takes a list of complex numbers and returns the corresponging list of points in the real plane.
}
  reals:=RealField(precision);
  V:=VectorSpace(reals,2);
  return [V|[Re(pt),Im(pt)] : pt in cmplxPts]; 
end intrinsic;

intrinsic planeToComplex(planePts::Any :precision:=20) -> Any
{
  Takes a sequence of points in the real plane and outputs the corresponding sequence of complex points.
}
  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);
  return [pt[1]+pt[2]*I : pt in planePts];
end intrinsic;

intrinsic PathFinder1(f0::RngMPolElt,f1::RngMPolElt) -> Any, Any
{
  See SetupIntegrationPaths.
}
  printf "\nPathFinder1 initiated. ";
  time0 := Cputime();
  sFibs:=singularFibersOfPencil(f0,f1);
  sFibs2D:=complexToPlane(sFibs);
  path:=findPath(sFibs2D);
  printf "PathFinder1 terminated in "*Sprint(Cputime()-time0)*" seconds.";

  return path, sFibs2D;
end intrinsic;


// input: f0,f1 two hom polys of same degree
// output: the values of t for which the hypersurface (1-t)*f0+t*f1 is singular
// assuming general fiber is smooth
intrinsic singularFibersOfPencil(f0::RngMPolElt,f1::RngMPolElt : KK:=ComplexField(20)) -> Any
{
  Finds the coordinates in t of the singular fibers of a pencil of hypersurfaces defined by (1-t)*f0+t*f1.
}
  P:=Parent(f0);
  R<t>:=PolynomialRing(Rationals(),Ngens(P)+1,"elim",1);
  inc:=hom<P->R|[R.i : i in [2..Ngens(R)]]>;
  F:=(1-t)*inc(f0)+t*inc(f1);
  I:=ideal<R|[Derivative(F,i): i in [2..Ngens(R)]]>;
  J:=ideal<R|[R.i : i in [2..Ngens(R)]]>;
  IJ:=Saturation(I,J);
  gb:=GroebnerBasis(IJ);
  polys:=[p : p in gb | IsUnivariate(p,t)];
  rts:=[KK|];
  for p in polys do
    _,h:=IsUnivariate(p);
    rts:=rts cat [r[1] : r in Roots(h,KK)];
  end for;
  return rts;
end intrinsic;

// avoid is a sequence of points in a 2 dimensional real vector space
// maxsteps is the number of steps in the rectilinear path
// output is a rectilinear path from p0 to p1 avoiding the list of points as much as possible
// N and n control the evolutionary algorithm, N=sample size, n=survivors from each generation
intrinsic findPath(avoid::[ModTupFldElt],p0::ModTupFldElt,p1::ModTupFldElt : maxSteps:=5, n:=5,N:=100) -> Any,Any
{
  Uses an evolutionary algorithm to find a rectilinear path from p0 to p1 in the real plane avoiding the points in the list "avoid".
}
  V:=Parent(p0); // the real plane, i.e. a vector space of dim 2 over a real field
  avoid:=[a : a in avoid | not ((a eq p0) or (a eq p1))];

  if #avoid eq 0 then 
    return [p0,p1], 0;
  end if;

  bestPaths:=[[p0] : i in [1..n]];
  weights:=[Field(V)|0:i in [1..n]];

  centers:=[V![i/maxSteps,0] : i in [0..maxSteps]];
  rangex:=2/maxSteps;

  if maxSteps eq 1 then
    return [p0,p1], weight([p0,p1],avoid);
  end if;

  for step in [1..(maxSteps-1)] do
    for i in [1..n] do
      newPaths:=[];
      newWeights:=[];
      path:=bestPaths[i];
      rps:=randomPoints(V,N : center:=centers[step],ranges:=[rangex,1]);
      for p in rps do
        newpath,wt,problem:=addSegment(path,p,avoid);
        wt:=wt*(p-p1,p-p1)*maxSteps/(maxSteps-step);
        if problem then break; end if;
        if step eq maxSteps-1 then
         newpath,wt2,problem:=addSegment(newpath,p1,avoid);
         wt2:=wt2*(p-p1,p-p1)*maxSteps/(maxSteps-step);
         wt:=wt+wt2;
          if problem then break; end if;
        end if;
        Append(~newPaths,newpath);
        Append(~newWeights,weights[i]+wt);
      end for;
      ParallelSort(~newWeights,~newPaths);
      bestPaths[i]:=newPaths[1];
      weights[i]:=newWeights[1];
    end for;
  end for;

  // try also the straight path
  str:=[p0,p1];
  wt:=weight([p0,p1],avoid);
  if not wt eq -1 then
    Append(~weights,wt);
    Append(~bestPaths,str);
  end if;
  ParallelSort(~weights,~bestPaths);

  return bestPaths[1], weights[1];
end intrinsic;

intrinsic findPath(avoid::[ModTupFldElt] : maxSteps:=5, n:=5,N:=100) -> Any,Any
{
  Uses an evolutionary algorithm to find a rectilinear path from 0 to 1 in the real plane avoiding the points in the list "avoid".
}
  if #avoid eq 0 then
    V:=VectorSpace(RealField(20),2);
  else 
    V:=Parent(avoid[1]);
  end if;
  p0:=V!0; p1:=V![1,0];
  return findPath(avoid,p0,p1 : maxSteps:=maxSteps, n:=n,N:=n);
end intrinsic;


intrinsic squareDistance(lineSegment::SeqEnum,pt::ModTupFldElt) -> Any
{ Returns the closest point in a line seqment to the given point.}
  v:=lineSegment[1];
  w:=lineSegment[2];
  if v eq w then
    return (v-pt,v-pt);
  end if;
  t:=(w-v,pt-v)/(w-v,w-v);
  tt:=Maximum(0,Minimum(t,1));
  closestPoint:=v+tt*(w-v);
  return (closestPoint-pt,closestPoint-pt);
  //return v+tt*(w-v);
end intrinsic;

intrinsic weight(lineSegment::SeqEnum,pts::[ModTupFldElt]) -> Any
{
  Assigns a weight to the line segment depending on how close the given list of points are.
}
  wgt:=0;
  for pt in pts do
    dist:=squareDistance(lineSegment,pt);
    if dist eq 0 then
      return -1;
    end if;
    wgt+:=1/dist;
  end for;
  return wgt;
end intrinsic;


intrinsic randomPoints(V::ModTupFld,num::RngIntElt : center:=(V!0), ranges:=[2: i in [1..Dimension(V)]]) -> SeqEnum
{
  Randomly generates "num" points in V.
}
  Reals:=RealField(20);
  F:=Field(V);
  d:=Dimension(V);
  return [center + V![Reals|Random([-ranges[j],ranges[j]])*Random(10^20)/10^20 : j in [1..d]] : i in [1..num]];
end intrinsic;

intrinsic addSegment(path::[ModTupFldElt],newPoint::ModTupFldElt,avoid::[ModTupFldElt]) -> Any,Any,Any
{
  Tries to add a new line seqment to an existing rectilinear path.
}
  problem:=false;
  if path[#path] eq newPoint then 
    problem:=true;
  end if;
  newSegment:=[path[#path],newPoint];
  wt:=weight(newSegment,avoid);
  if wt eq -1 then 
    problem:=true;
  end if;
  return Append(path,newPoint),wt,problem;
end intrinsic;

intrinsic test( : name:="") -> Rec
{ Try a simple polynomial with PeriodHomotopy. }
  P3<x,y,z,w>:=PolynomialRing(Rationals(),4);
  path:=[
  4*x^4 + 2*y^4 - 6*z^4 - 9*w^4,
  4*x^4 - 6*x*w^3 + 2*y^4 - 6*z^4 - 9*w^4,
  4*x^4 - 6*x*w^3 + 2*y^4 - 6*z^4,
  4*x^4 - 9*x*z*w^2 - 6*x*w^3 + 2*y^4 - 6*z^4
  ];
  return PeriodHomotopy(path : reduce_initials:=true, pathfinder:=0,name:=name, overwrite:=true);
  //f:=4*x^4 - 9*x*z*w^2 - 6*x*w^3 + 2*y^4 - 6*z^4;
  //PeriodHomotopy(f : pathfinder:=1);
end intrinsic;

intrinsic test_curve() -> Rec
{ Try a large genus curve with PeriodHomotopy. }
  P3<x,y,z>:=PolynomialRing(Rationals(),3);
  return PeriodHomotopy(x^21+y^21+z^21+(x*y*z)^7 : precision:=20, reduce_initials:=false);
end intrinsic;


intrinsic test_massive_curve( :k:=10) -> Rec
{ Try a very large genus curve with PeriodHomotopy. }
  P3<x,y,z>:=PolynomialRing(Rationals(),3);
  deg:=3*k;
  return PeriodHomotopy(x^deg+y^deg+z^deg+(x*y*z)^k : precision:=20, reduce_initials:=false);
  //return PeriodHomotopy(x^16+y^16+z^16+x^5*y^5*z^6 : precision:=20);
end intrinsic;


// input:
// dervs - a list of lists, entries are polynomials designating forms
// type - the type of the fermat curve over which we are integrating
// output:
// the integral of each form over the pham cycles in the fermat curve
intrinsic massIntegrate(dervs::SeqEnum, deg::RngIntElt, type::SeqEnum : precision:=200) -> Any,Any
{
  Integrates a list of list of polynomials (to be viewed as cohomology classes) over a Pham basis for a Fermat hypersurface with coefficients given by "type". 
}

  print "\nComputing the initial conditions on Fermat.";
  R:=Parent(dervs[1,1]);
  K:=CoefficientRing(R);
  n:=Ngens(R)-2; 
  // all monomials occuring in the entire collection
  mons:=Setseq(Seqset(&cat[Monomials(form) : form in &cat(dervs)]));
  alphas:=[[i+1: i in Exponents(m)] : m in mons];

  print "Constructing a Pham basis and its intersection matrix.";
  phamBasis:=WriteToFileHomAndCohOfFermat(n,deg);
  print "Construction complete";
  CC<I>:=ComplexField(precision);
  V:=RSpace(CC,#phamBasis);
  print "Integrating each monomial term";
  integrals:=integrateMonomials(alphas,deg,phamBasis : type:=type,precision:=precision);
  //integrals:=[V|integrateMonomial(alpha,deg,phamBasis : type:=type,precision:=precision) : alpha in alphas];
  print "Monomial integration complete.";
  integrals:=[V| period : period in integrals];
  print "Adding the integrals of monomials for each polynomial.";
  result:=[[[] : u in derv ] : derv in dervs];
  for j in [1..#dervs] do
    //printf "\nPutting together monomial integrals of form %o in %o", j, #dervs;
    for i in [1..#(dervs[j])] do
      indexSet:=[Index(mons,m) : m in Monomials(dervs[j,i])];
      result[j,i]:=Coordinates(V,&+[MonomialCoefficient(dervs[j,i],mons[mm])*integrals[mm]  : mm in indexSet]);
    end for;
  end for;
  
  return result,phamBasis;
end intrinsic;

intrinsic PrimitiveToComplete(X::Rec) -> Any
{
  Completes the primitive homology of X. Outputs the modified X which includes the transition matrix from primitive periods to complete periods.
}
  d:=X`degree;
  n:=X`dimension;
  phamB:=X`phamBasis;
  // if dimension is odd, primitive homology coincides with homology
  if X`dimension mod 2 eq 1 then
    X`primitiveToComplete:=IdentityMatrix(Rationals(),#phamB);
    X`intersectionMatrix:=X`primitiveIntersectionMatrix;
    return X;
  end if;
  IM:=ChangeRing(X`primitiveIntersectionMatrix,Rationals());
  // Using:
  // Degtyarev and Shimada intersection numbers
  // Theorem 2.2, arXiv:1405.4683v3
  // for explanations see: Lairez, Sertoz -- Numerical Hodge Rank
  // the helper tau function
  function tau(i)
    if i mod (2*d) eq 1 then return 1;
    elif i mod (2*d) eq 2*d-1 then return -1;
    end if;
    return 0;
  end function;
  // L is the class of a particular linear subscheme of half-dimension in Fermat.
  function intersectLwith(beta)
    return tau(2*beta[n+1]-2*beta[n+2]-1)*&*[tau(2*beta[2*i-1] - 2*beta[2*i] + 1) : i in [1..(n/2)]];
  end function;
  // We will now compute the projection of L into the primitive homology.
  intL:=Matrix([[intersectLwith(beta) : beta in phamB]]);
  IMinv:=Determinant(IM)^(-1)*Adjoint(IM);
  kappa:=ChangeRing(intL,Rationals())*IMinv;
  //self intersection of kappa
  kappaSelfIntersection:= kappa*IM*Transpose(kappa);
  // L = 1/d hyp + kappa
  // since hyp^2 = d
  // L^2 = 1/d + kappa^2 
  LSelfIntersection:=Integers()!(kappaSelfIntersection[1,1]+1/d);
  // form the intersection matrix for homology by using L^2 and intL
  fullIM:=VerticalJoin(X`primitiveIntersectionMatrix,intL);
  temp:=Transpose(HorizontalJoin(intL,Matrix([[LSelfIntersection]])));
  fullIM:=HorizontalJoin(fullIM,temp);
  X`intersectionMatrix:=fullIM;
  // the hyperplane class
  // L = 1/d hyp + kappa
  // hyp = d*L - d*kappa
  X`polarization:= Matrix(HorizontalJoin(ChangeRing(-d*kappa,Integers()),Matrix([[d]])));
  X`primitiveToComplete:=HorizontalJoin(IdentityMatrix(Rationals(),#phamB),Transpose(kappa));
  return X;
end intrinsic;

// hodge lattice
// rank: rank of the Hodge lattice
// lattice: the intersection matrix of the lattice
// basis: the basis of the lattice in terms of the basis for homology, together with a linear class
// degrees: degrees of the algebraic cycles generating the lattice
// parameters: numerical parameters used for the computation of the hodgeLattice, such as the offset and precision
hodgeLattice := recformat<rank,lattice,basis,polarization,degrees,parameters>;


intrinsic HodgeLattice(X::Rec : offset:=20 , precision:=X`precision) -> Rec
{
  Takes the output of PeriodHomotopy and computes the lattice of Hodge cycles of middle dimension for the target hypersurface.
}

  assert X`dimension mod 2 eq 0;
  // the dimension of F^(n/2+1)
  dim:=#[ omega  : omega in X`cohomBasis | Degree(omega) eq (X`degree * X`dimension/2 - X`dimension-2)];
   // Binomial(Ceiling(X`dimension/2)*X`degree,X`dimension+2);
  // in case full matrix of periods are computed, we use only half
  rho,basis:=LatticeOfRelations(Matrix(X`periods[1..dim]),precision: offset:=offset);

  IM:=X`intersectionMatrix;
  hyp:=X`polarization;
  degrees:=[Matrix([b])*IM*Transpose(hyp) : b in basis]; 

  lattice:=Matrix(basis)*IM*Transpose(Matrix(basis));

  //polarization, in the coordinates of the lattice
  Lambda:=LatticeWithBasis(Matrix(basis));
  hyp:=hyp[1]; // this command converts the one-row-matrix hyp to a row vector
  polarization:=Matrix([Coordinates(Lambda!hyp)]);

  hdgLattice := rec<hodgeLattice | rank:=rho, lattice:=lattice, basis:=basis, degrees:=degrees, parameters:=[X`precision,offset], polarization:=polarization>;

  X`hodgeLattice:=hdgLattice;
  X`lat:=lattice;
  X`pol:=polarization;

  return X,rho,lattice;

end intrinsic;

intrinsic HomologyAndCohomologyForFermat(n::RngIntElt,d::RngIntElt) -> Any, Any
{
  Returns a grevlex basis for cohomology of a Fermat hypersurface of degree d and dimension n as well as a Pham basis. The cohomology basis consists of monomials which are represented by their exponents increased by one for compatibility with literature.
}

  f:=Fermat(n,d);
  cohomology:=FermatCohomologyBasis(f);
  homology:=PhamBasis(n,d);
  alphas:=[[i+1: i in Exponents(m)] : m in cohomology];

  return homology,alphas;
end intrinsic;

intrinsic WriteToFileHomAndCohOfFermat(n::RngIntElt,d::RngIntElt) -> Any,Any
{
  If the file does not exist, then the homology and cohomology of Fermat hypersurface of dimension n and degree d is computed and written to the appropriate place for other SageMath scripts to read. Returns the pham basis and the intersection matrix.
}
  filename1:="fermat-"*Sprint(n)*"-"*Sprint(d)*".sage";
  filename2:="pham-"*Sprint(n)*"-"*Sprint(d);
  // check if the file exists, do nothing if it exists already
  File1DoesNotExist:=(System("test -e "*PeriodSuiteStorageDir()*filename1) ne 0);
  File2DoesNotExist:=(System("test -e "*PeriodSuiteStorageDir()*filename2) ne 0);
  if File1DoesNotExist or File2DoesNotExist then
    B,A := HomologyAndCohomologyForFermat(n,d); 
    // there should be nothing to overwrite, but just to be sure
    WriteInsideStorageFolder(filename1,"alphas="*Sprint(A) : Overwrite:=true); 
    WriteInsideStorageFolder(filename1,"betas="*Sprint(B)); 
    s:=&*[ Sprint(B[i])*"\n" : i in [1..(#B-1)]]*Sprint(B[#B]);
    WriteInsideStorageFolder(filename2,s : Overwrite:=true); 
  else
    print "Pham basis computation has already been saved to file.";
    B:=PhamBasis(n,d); // this will automatically read the file
  end if;

  return B, PhamIntersectionMatrixFromBasis(B,d);

end intrinsic;

// this could be drastically improved
intrinsic CoordinatesInReducedCohomologyBasis(f::RngMPolElt,basis::[RngMPolElt],forms::[RngMPolElt]) -> SeqEnum
{
  If the basis is known to be reduced then this computes the coordinates of the given list of forms in cohomology with respect to the given basis. User must check that basis is reduced. 
}
  rB:=GriffithsDwork(forms,f : depth:=1); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in (rB cat basis)]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in basis];
  rb2:=[[MonomialCoefficient(b,m) : m in mons] : b in rB];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [Coordinates(W,W!b) : b in rb2];
end intrinsic;

intrinsic FormLoop(f0::RngMPolElt,f1::RngMPolElt : pathfinder:=0) -> SeqEnum
{
  Computes a path which goes from f0 to some g near f1 and loops counterclockwise around f1 back to g. This loop contains no other singular hypersurfaces except f1, which is assumed to be singular.
}
  sings:=singularFibersOfPencil(f0,f1);
  assert 1 in sings;
  distance_to_closest_singularity:=Sort([Abs(s-1) : s in sings])[2];
  dist:=1/2*Minimum(0.2,distance_to_closest_singularity);
  //form a diamond around 1.

  // complex plane
  V:=VectorSpace(RealField(20),2);
  loop_head:=[V|[1-dist,0],[1,-dist],[1+dist,0],[1,dist],[1-dist,0]];
  // in future, this should be combined with path finder
  // remove 1 from the set of singularities and cast complex points to real plane
  if pathfinder eq 1 then
    avoid:=complexToPlane(Remove(sings,Index(sings,1)));
  else 
    avoid:=[];
  end if;
  path_before_loop_head:=findPath(avoid,V!0,loop_head[1]);
  path_end:=[V![1,0]];
  path:=path_before_loop_head cat loop_head[[2,3,4,5]] cat path_end;

  // third entry records the position of the loop head
  return path, avoid, #path_before_loop_head;
end intrinsic;


intrinsic multiply(A::Any,B::Any) -> Any
{
  Try computing A*B by coercing the coefficients of B into the ring of A and, if this fails, then the other way around.
}
  try 
    return A*ChangeRing(B,Parent(A[1,1]));
  catch e
    return ChangeRing(A,Parent(B[1,1]))*B;
  end try;
  error "Entries of neither matrix can be coerced into the ring of the entries of the other matrix.";
end intrinsic;

intrinsic Monodromy(M::Any,N::Any, precision::RngIntElt : offset:=20) -> Any,Any,Any
{
  Given two complex floating point matrices M and N of the same size (with "precision" number of digits reliable), find small invertible integral matrices B1,B2 such that MB1=NB2. We return B1,B2,B2*B1inv.
}
  try
    N:=Parent(M)!N;
  catch e
    M:=Parent(N)!M;
  end try;
  _,rels:=LatticeOfRelations(HorizontalJoin(M,N),precision : offset:=offset);
  try 
    ncol:=Ncols(M); // assumed to be the same with N
    rels:=Matrix(rels);
    B1:=Transpose(ExtractBlock(rels,1,1,ncol,ncol));
    B2:=-Transpose(ExtractBlock(rels,1,1+ncol,ncol,ncol));
    //assert (Determinant(B1) ne 0) and (Determinant(B2) ne 0);
    F:=CoefficientRing(Parent(M));
    b1:=ChangeRing(B1,F);
    b2:=ChangeRing(B2,F);
    b:=b2*Inverse(b1);
    ZB:=Matrix([[Integers()|Round(b[i,j]) : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
    B:=Matrix([[F|ZB[i,j] : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
    errorRing<I>:=ComplexField(1);
    // WARNING: Scaling the error to exaggerate size.
    scale:=10^precision;
    allErrors:=Eltseq(ChangeRing(scale*(Matrix(M) - Matrix(N)*B),errorRing));
    maximumError:=SquareRoot(Maximum([Norm(e): e in allErrors]));
    print "If the result is reliable, error should be around 1. Anything less is an indication of a stronger match. If there is no match, expect an error of magnitude 10^"*Sprint(precision)*".";
    print "Obtained an error of:", maximumError, "\n";
  catch e
    error "It seems, these matrices are not related by a monodromy.";
  end try;
  return B1,B2,ZB;
end intrinsic;

intrinsic PicardLefschetz(X::Any) -> Any
{
  Assuming X was a PeriodBundle computed with singular target, this function will compute the the monodromy operator around the target in the final family, attach it to X and return X;
}
  _,_,ZB:=Monodromy(X`loopEnds,X`loopBegins,X`precision);
  X`monodromy:=ZB;
  return X;
end intrinsic;


intrinsic GetWeightFiltration(X::Any) -> Any, Any
{Computes the weight filtration induced by the monodromy around the singular fiber.}
  N,k:=LogarithmOfMonodromy(X`monodromy);
  return WeightFiltration(N,k);
end intrinsic;

// This could be made purely combinatorial, but anyway...
intrinsic LogarithmOfMonodromy(T::AlgMatElt) -> AlgMatElt,RngIntElt
{A power m of T is unipotent hence log(T) is a well defined nilpotent operator N. This function returns the triple N,nilpotency(N),m}
  minpol:=MinimalPolynomial(T);
  facts:=Factorization(minpol);
  orders:=[];
  multiplicities:=[];
  for fact in facts do
    _,o:=IsCyclotomicPolynomial(fact[1]); 
    Append(~orders,o);
    Append(~multiplicities,fact[2]);
  end for;
  lcm:=LCM(orders);
  U:=Parent(minpol);
  unipotency:=0;
  repeat
    unipotency +:=1;
    pol:=(U.1^lcm-1)^unipotency;
  until pol/minpol in U;
  return 1/lcm*&+[(-1)^(m+1)/m*(T^lcm-1)^m : m in [1..(unipotency-1)]],unipotency,lcm;
end intrinsic;

// WARNING: N acts by right multiplication
intrinsic WeightFiltration(N::AlgMatElt, orderOfN::RngIntElt : transpose:=false) -> AlgMatElt,SeqEnum
{
  Computes the weight filtration induced by the nilpotent operator N.
}
  if transpose then N:=Transpose(N); end if;
  N:=ChangeRing(N,Rationals());
  assert Ncols(N) eq Nrows(N);
  n:=Ncols(N);
  V:=VectorSpace(Rationals(),n);
  k:=orderOfN-1;
  assert N^(k+1) eq 0;
  // indices will be shifted by -2
  // filtration[i] = W_(i-2)
  filtration:=[]; 
  filtration[2*k+2]:=V; // 2k
  filtration[1]:=sub<V|0>; //-1
  for j in [0..k] do // W_{2k-j} = W_{k+(k-j)}
    i:=k-j; K1:=Kernel(N^(i+1)); 
    //K2:=W(k+i+2)*N;
    ii:=k+i+2; jj:=ii+2;
    if IsDefined(filtration,jj) then K2:=filtration[jj]; 
    elif ii ge 2*k then K2:=V; 
    elif ii le 0 then K2:=sub<V|0>;
    else
      error "undefined";
    end if;
    U:=K1+K2;
    filtration[k+i+2]:=U;
    filtration[k-i+2]:=U*N^i;
  end for;
  dims:=[Dimension(K) : K in filtration];
  B:=[];
  for V in filtration do
    B:=ExtendBasis(B,V);
  end for;
  function W(i)
    j:=i+2;
    if IsDefined(filtration,j) then return filtration[j]; end if;
    if i ge 2*k then return V; end if;
    if i le 0 then return sub<V|0>; end if;
    error "undefined";
  end function;
  return Matrix(B), dims, W;
end intrinsic;



// computing first order deformation of de Rahm cohomology
intrinsic DifferentiateCohomologyClasses(f::RngMPolElt,cohom_classes::SeqEnum,tangent_directions::SeqEnum) -> SeqEnum 
{
  Given a list of cohomology classes (a list of polynomials) and a list of tangent directions (a list of polynomials of degree deg(f)) output the coordinates of the differentiated cohom_classes for each tangent direction (using grevlex basis of cohomology).  
}
  
  // TODO: check that forms are of the right degrees, so they indeed give cohom classes
  differentials:=[[DifferentiateForm(q,f,f+m) : q in cohom_classes] : m in tangent_directions];
  B:=ComputeCohomologyBasis(f : order:="grevlex"); 
  return CoordinatesInCohomology(f,B,differentials);

end intrinsic;

intrinsic DifferentiateCohomology(f::RngMPolElt,tangent_directions::SeqEnum) -> SeqEnum
{
  Given a list of tangent directions (a list of polynomials of degree deg(f)) output the coordinates of the differentiated grevlex cohomology basis for each tangent direction (using grevlex basis of cohomology).  
}
  B:=ComputeCohomologyBasis(f : order:="grevlex"); 
  differentials:=[[DifferentiateForm(q,f,f+m) : q in B] : m in tangent_directions];
  return [ Matrix(#B,#B,coords) : coords in CoordinatesInCohomology(f,B,differentials)];
  // the i-th row of each matrix is the coordinates of the i-th basis element of the basis
end intrinsic;

intrinsic DifferentiateCohomology(f0::RngMPolElt,f1::RngMPolElt) -> SeqEnum
{
  For the family (1-t)f0 + tf1, we compute the derivatives of a compatible cohomology basis at t=0.  
}
  B:=CompatibleCohomologyBasis(f0,f1);
  return CoordinatesInCohomology(f0,B,[DifferentiateForm(q,f0,f1) : q in B]);
end intrinsic;

intrinsic UpdateIntegrationPath(X,family_number : pathfinder:=1)
{
  Changes the integration paths for the deformation family that is specified by the given number.
}
  number:=family_number;
  def:=X`deformation;
  odes:=X`odes[number];
  f0:=def[number]; f1:=def[number+1];
  integrationPath,avoid,loop_position:=SetupIntegrationPath(f0,f1,pathfinder);
  for i in [1..#odes] do
    ode_filename:="IVP-"*suffix(number,#def-1)*"-"*suffix(i,#odes)*".sage";
    WriteInsideTempFolder(ode_filename,"path="*Sprint(integrationPath):name:=X`name);
  end for;
end intrinsic;

intrinsic PeriodsOfHodgeCycles(X::Rec,hodgeCycles::Any : precision:=0) -> Any
{
  Computes the periods of given Hodge classes against H^(n/2,n/2). Hodge classes must be given as rows of a matrix, each row representing the coordinates of the Hodge class with respect to the Hodge lattice (X`hodgeLattice`basis).
}

  assert (X`dimension mod 2) eq 0;
  assert HasAllPeriods(X);

  // dimensions of filtrations, so that dim H^(n/2,n/2) = dim2-dim1
  if precision eq 0 then
    CC<I>:=Parent(X`periods[1,1]);
  else 
    CC<I>:=ComplexField(precision);
  end if;
  NS:=Matrix(X`hodgeLattice`basis);
  return 1/(2*Pi(CC)*I)*ChangeRing(Matrix(hodgeCycles)*NS,CC)*Transpose(ChangeRing(X`periods,CC));

end intrinsic;

intrinsic round(matrix ::ModMatFldElt : dec:=5) -> Any
{
  Given a matrix with floating point entries, rounds each entry to "dec" number of decimal points.
}
  return Matrix(Nrows(matrix),Ncols(matrix),[ComplexField(dec)| (Abs(e) lt 10^-dec) select 0 else e : e in Eltseq(matrix)]);
end intrinsic;


// lattice is a matrix representing the intersection product on the picard group of a k3 surface
// polarization is the coordinates of a very ample line bundle in the picard group
// degree is the maximal degree of rational curves which will be computed
intrinsic P1InK3Lattice(lattice::Any,polarization::Any:degree:=3) -> Any
{
  Computes the smooth rational curves inside the Picard lattice of a K3 surface. (Currently implemented only upto degree three.)
}

  if not degree eq 3 then return Error("Not implemented"); end if;

  // rank of lattice
  rho:=Ncols(lattice);
  //basis
  id:=IdentityMatrix(Integers(),rho);
  // degree of polarization 
  d:=norm(polarization,lattice);

  // projection map (scaled by d)
  // d*id - lattice*polarization
  proj:=Matrix([ d*e - inner(e,lattice,polarization)*polarization[1] : e in Rows(id) ]);
  basis:=Matrix(Basis(RowSpace(proj)));
  prim:=-basis*lattice*Transpose(basis);
  gcd:=GCD(Eltseq(prim));
  primReduced:=Matrix(rho-1,rho-1, [Integers()|p/gcd : p in Eltseq(prim)]);
  L:=Lattice(IdentityMatrix(Integers(),Nrows(basis)),primReduced);


  // find potential rational curves
  // you could do better here -- just compute all weights in a range?
  all_curves:=[**];
  for i in [1..degree] do
    // norm of the projection of a rational curve of degree i is kappa[i]
    kappa:=(d*(2*d+i^2)/gcd); 
    if IsIntegral(kappa) then
      kappa:= Integers()!kappa;
      sv:=ShortVectors(L,kappa,kappa);
    else
      sv:=[];
    end if;
    // add or subtract polarization
    candidates:=[ Matrix(s[1])*basis + i*polarization: s in sv] cat [ Matrix(s[1])*basis - i*polarization : s in sv];
    // check the ones that would be integral even after dividing by d
    divisible:=[ Vector(l) : l in candidates | GCD(Eltseq(l)) mod d eq 0 ];
    // now fix the signs of non-effective classes
    finalists:=[];
    for l in divisible do
      if inner(l,lattice,polarization) gt 0 then
        Append(~finalists,l);
      else
        Append(~finalists,-l);
      end if;
    end for;

    // in case of duplicates, we trim them
    trim:=Seqset(finalists);

    // now divide 
    curves:=[ Vector([Integers()!(e/d) : e in Eltseq(l) ])  : l in trim];
    Append(~all_curves,curves);
  end for;

    // this could be automated for arbitrary degrees, but the fast version is here
  lines:=all_curves[1];

  if #lines eq 0 then
    quadrics:=all_curves[2];
    twisted_cubics:=all_curves[3];
  else
    linePairing:=Matrix(lines)*lattice*Transpose(Matrix(lines));
    // i1,i2 indicies of two lines in lines
    function lines_intersect(i1,i2)
      return linePairing[i1,i2] eq 1;
    end function;

    planar_pairs:={lines[i]+lines[j] : i,j in [1..#lines] | lines_intersect(i,j)};

    quadrics:=Setseq({ q : q in all_curves[2] | not q in planar_pairs});

    degenerate_cubics1:=[];
    for i in [1..#lines] do
      // find triplets i,j,k such that li intersects lj and lk but lj does not intersect lk
      // as i is distinguished here, we put that first, but j and k are not distinguished so
      // we order according to magnitude, so the triplets [i,j < k] are unique
      // we retain the sum li+lj+lk
      degenerate_cubics1 cat:=[&+lines[[i,j,k]] : j,k in [1..#lines]| j lt k and lines_intersect(i,j) and lines_intersect(i,k) and (not lines_intersect(j,k))];
    end for;

    if #quadrics eq 0 then
      degenerate_cubics2:=[];
    else
      line_cap_quadric:=Matrix(lines)*lattice*Transpose(Matrix(quadrics));
      degenerate_cubics2:=[ lines[i]+quadrics[j] : i in [1..#lines], j in [1..#quadrics] | line_cap_quadric[i,j] eq 1 ];
    end if;

    degenerate_cubics:=Seqset(degenerate_cubics1 cat degenerate_cubics2);
    twisted_cubics:=Setseq(Seqset(all_curves[3]) diff degenerate_cubics);

  end if;


  // if degree is greater than 3 then use the following... not implemented yet
  

  print "The number of lines, quadrics, twisted cubics:";
  print #lines,#quadrics,#twisted_cubics;

  return lines, quadrics,twisted_cubics;
end intrinsic;


// Rm x Rn -> R(m+n) -> R(m+n)/Jac(X)
intrinsic MultiplyAndReduce(f::RngMPolElt,u::RngIntElt,v::RngIntElt) -> EltSeq
{
  For each monomial of degree m, computes the products with monomials of degree n and reduces these products modulo the jacobian ideal of f using grevlex ordering. The output is a sequence of matrices, one for each monomial of degree m, expressing this map.
}
  R:=Parent(f); n:=Ngens(R)-2; d:=Degree(f);
  assert u+v eq (n/2+1)*d-n-2;
  R1:=MonomialsOfDegree(R,u);
  R2:=MonomialsOfDegree(R,v);
  prods:=[[ mon1*mon2 : mon2 in R1] : mon1 in R2];
  B:=ComputeCohomologyBasis(f : order:="grevlex"); 
  // M[i] will be a matrix whose *rows* correspond to coordinates of entries in prods wrt B
  return [CoordinatesInCohomology(f,B,prod) : prod in prods];
end intrinsic;

intrinsic MultiplyAndReduce(f::RngMPolElt,u::RngIntElt) -> EltSeq
{
  For each monomial of degree u, computes the products with monomials of complimentary degree and reduces these products modulo the jacobian ideal of f using grevlex ordering. The output is a sequence of matrices, one for each monomial of degree u, expressing this map.
}
  d:=Degree(f); n:=Ngens(Parent(f))-2; // dimension of Z(f)
  assert n mod 2 eq 0;
  v:=Integers()!(n/2+1)*d-n-2-u;
  return MultiplyAndReduce(f,v,u);
end intrinsic;

intrinsic PolynomialsVanishingOnHodgeCycle(X::Rec, hodgeCycle::Any, degree::RngIntElt : working_precision:=Ceiling(X`precision*0.8)) -> Any
{
  Takes as input a Period bundle X, a Hodge cycle represented in the coordinates of the Hodge lattice of X, and the desired degree of polynomials "vanishing" on this Hodge cycle.
}
  precision:=Minimum(X`precision,2*working_precision);
  P:=PeriodsOfHodgeCycles(X,hodgeCycle : precision:=precision);
  M:=MultiplyAndReduce(X`equation,degree);
  PM:=Matrix([P * ChangeRing(Transpose(m),ComplexField(precision)) : m in M]);
  // at this point we've lost some precision so use fewer precision
  epsilon:=10^-(Floor(working_precision*0.9));
  cleanPM:=Matrix(Nrows(PM),Ncols(PM),[ComplexField(working_precision)| Abs(e) lt epsilon select 0 else e  : e in Eltseq(PM) ]);
  K:=Kernel(cleanPM); 
  dimK:=Dimension(K);
  print "There are "*Sprint(dimK)*" equations of degree "*Sprint(degree)*" vanishing on this cycle.";
  return [HomogenizeCoordinate(Eltseq(k),working_precision) : k in Basis(K)];
end intrinsic;


intrinsic HomogenizeCoordinate(point::[FldElt],precision::RngIntElt) -> SeqEnum
{
  Given a sequence of values over a non-exact real or complex field, scale the sequence so that the first non-zero coordinate is one. An element is considered zero if it is indistinguishable from zero according to our precision.
}
  i:=0;
  repeat
    i+:=1;
    if i gt #point then return [Parent(point[1])|0 : i in [1..#point]]; end if;
  until Abs(point[i]) gt 10^-(Floor(precision/2));
  return [p/point[i] : p in point];
end intrinsic;

//************************************************************************************************
// Shioda's computation of the Picard numbers for Delsarte surfaces, used for testing mainly
//************************************************************************************************

intrinsic picardNumberOfDelsarte(f::RngMPolElt) -> RngIntElt
{
  Compute the Picard number of a Delsarte surface whose exponents are defined by the 4x4 integral matrix A.
}
  mons:=Monomials(f);
  assert #mons eq 4;
  A:=Matrix([ Exponents(m) : m in mons]);
  return picardNumberOfDelsarte(A);
end intrinsic;

intrinsic picardNumberOfDelsarte(A::AlgMatElt) -> RngIntElt
{
  Compute the Picard number of a Delsarte surface whose exponents are defined by the 4x4 integral matrix A.
}
  // Checking Delsarte conditions for a surface
  // A is a 4x4 matrix with non-negative entries
  assert (Ncols(A) eq 4) and (Nrows(A) eq 4);
  assert &and[(a in Integers()) and (a ge 0) : a in Eltseq(A)];
  // Sums of rows of A is constant (the corresponding poly is hom)
  m:=&+Eltseq(A[1]);
  assert &and[&+Eltseq(A[i]) eq m : i in [1..4]];
  // The matrix is invertible
  detA:=Determinant(A);
  assert detA ne 0;
  // The polynomial is not divisible by a coordinate function
  // equivalently, for each j, at least one row has a zero at j-th column
  assert &and[&or[A[i,j] eq 0 : i in [1..4]] : j in [1..4]];

  // The rest of the setup as in Shioda's paper:
  // "An explicit algorithm for computing the Picard number of certain surfaces"
  adjA:=Adjoint(A);
  delta:=GCD(Eltseq(adjA));
  assert delta gt 0; // just making sure GCD does the right thing
  d:=Integers()!(Abs(detA)/delta);
  Ainv:=1/detA*adjA;
  B:=ChangeRing(d*Ainv,Integers());
  Rd:=Integers(d);
  Md:=Kernel(Matrix([[Rd|1] : i in [1..4]]));
  LA:=Image(ChangeRing(B,Rd));
  // For computational efficiency we do not construct Ad or Bd explicitly
  Ad:={! m in Md | &and[ mi ne 0 : mi in Eltseq(m)] !};
  tset:={t : t in [1..d] | GCD(t,d) eq 1};
  // Bd should really consist of entries in Ad, instead of Md.
  // For the construction of IcapLA this doesn't matter.
  Bd:={! m in Md | &and[&+ChangeUniverse(Eltseq(t*m),Integers()) eq 2*d  : t in tset] !};
  IcapLA:={m : m in LA | (m in Ad) and (not m in Bd)};
  lambda:=#IcapLA;
  return (m-1)*(m^2-3*m+3)+1-lambda;
end intrinsic;


//************************************************************************************************
// Computing transition matrices of periods for GL-translates of hypersurfaces
//************************************************************************************************

intrinsic translate_polynomial(A::AlgMatElt,p::RngMPolElt) -> RngMPolElt
{
  Here A acts on Pn the points, hence Atranspose acts on p. Vieweing p as a function on the row (x0,..,xn) we map p to the poly p((x0,..,xn)*Atranspose).
}
  return Evaluate(p,Eltseq(Matrix([[Parent(p).i : i in [1..Ngens(Parent(p))]]])*ChangeRing(Transpose(A),Parent(p))));
end intrinsic;

intrinsic translate_form(A::AlgMatElt,p::RngMPolElt) -> RngMPolElt
{
  For the the linear map Pn -> Pn given by A, we have a pullback on meramorphic forms. Especially those of type p*Omega/f^l pullback to q*Omega/g^l. Given p we return q. 
}
  return Determinant(A)*translate_polynomial(A,p);
end intrinsic;

intrinsic translate_period_matrix(A::AlgMatElt,f::RngMPolElt) -> RngMPolElt
{
  Let g=translate_polynomial(A,f) be the translate of f. This function outputs a matrix M such that if P is a period matrix for the hypersurface Z(f) with respect to the grevlex cohom basis for f, then M*P is the grevlex period matrix for Z(g).
}
  // Idea: The pointwise action of A induces and isomorphism from Z(g) to Z(f). Identify the homology groups and therefore the integral cohomology groups with respect to this isomorphism. The resulting identification of cohomology groups is given by the obvious pullback on forms, which we implement via translate_form.
  // The grevlex period matrix of Z(f) thus is a period matrix of Z(g) with respect to the pullback of the grevlex Griffiths basis on Z(f). Express the grevlex Griffiths basis on Z(g) in terms of these pullbacks in order to find the desired M.
  g:=translate_polynomial(A,f);
  grevlex_basis:=ComputeCohomologyBasis(g : order:="grevlex"); 
  translate_basis:=[translate_form(A,p)  : p in ComputeCohomologyBasis(f : order:="grevlex")]; 
  N:=CoordinatesInCohomology(g,translate_basis,grevlex_basis);
  return N;
end intrinsic;

intrinsic transition_matrix(f0::RngMPolElt, f1::RngMPolElt : precision:=100, straight:=false,  pathfinder:=0, integrationPath:=[0,1], reduce_initials:=true,name:="",overwrite:=false,integrate:=true) -> Any,Any
{
  Returns the period transition matrix from f0 to f1 and its precision in digits. The period transition matrix is the matrix M such that if P is a period matrix of f0 w.r.t. grevlex cohomology basis than M*P is a period matrix of f1 w.r.t. grevlex cohomology basis.
}
  bound_pole_order:=false;
  assert Degree(f0) eq Degree(f1);
  assert isSmooth(f0);
  assert isSmooth(f1);

  beginningTime:=Realtime();
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  CheckIfIVPDirectoryExists(name, ivpdir, overwrite);

  WriteInsideTempFolder("meta.sage","precision="*Sprint(precision):name:=name);
  WriteInsideTempFolder("meta.sage","d="*Sprint(Degree(f0)):name:=name);
  //WriteInsideTempFolder("meta.sage","fermat_type="*Sprint(Coefficients(path[1])):name:=name);
  WriteInsideTempFolder("meta.sage","reduce=false":name:=name); // this will allow us not to compute periods of fermat
  
  target:=f1;
  target_is_smooth:=true;
  P:=Parent(target);
  n:=Ngens(P)-2;
  d:=Degree(target); 
  if d eq 1 then
    error "Degree of the hypersurface needs to be greater than one.";
  end if;

  odes:=[];
  tstart:=Realtime();
  ivps:=ConstructIVPs(f0,f1: pathfinder:=pathfinder, family_number:=1, integrationPath:=integrationPath, pole_order_bound:=0,precision:=precision, f1_is_smooth:=true);
  WriteIVPsToFile(ivps : number:=1, max_number:=1, name:=name);
  printf "\nComputation of the differential equations is now complete (%o seconds).\n\n", Realtime()-tstart;

  ////////////////////////////////////////
  /// Integration happens here ///////////
  ////////////////////////////////////////
  error_code:=CallIntegrator("integrator.sage", ivpdir);
  ////////////////////////////////////////
  ////////////////////////////////////////
  ivpdir:=IVPWorkingDir(:subfolder:=name);
  primitivePeriods,precision:=loadPeriods(ivpdir*"periods");

  return primitivePeriods, precision;
end intrinsic;

intrinsic grevlex_periods_of_fermat(f::RngMPolElt : precision:=100) -> Any
{ 
  Computes the primitive grevlex period matrix of a Fermat hypersurface.
}
  cohom_basis:=FermatCohomologyBasis(f);
  periods:=massIntegrate([ [w] : w in cohom_basis],Degree(f), Coefficients(f) : precision:=precision);
  return Matrix([ p[1] : p in periods]);
end intrinsic;
